<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NeRF_Representing-Scenes-as-Neural-Radiance-Fields-for-View-Synthesis</title>
      <link href="/2023/11/20/NeRF_Representing-Scenes-as-Neural-Radiance-Fields-for-View-Synthesis/"/>
      <url>/2023/11/20/NeRF_Representing-Scenes-as-Neural-Radiance-Fields-for-View-Synthesis/</url>
      
        <content type="html"><![CDATA[<h1>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</h1><p>论文链接：<a href="https://arxiv.org/abs/2003.08934">NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis | Abstract (arxiv.org)</a></p><p>仓库链接：<a href="https://github.com/bmild/nerf">bmild/nerf: Code release for NeRF (Neural Radiance Fields) (github.com)</a></p><h2 id="Abstract">Abstract</h2><p>我们将展示一种方法，可以通过稀疏的输入图片，合成复杂场景。我们的算法通过全连接的深度网络表现场景，其输入是连续的5D坐标（空间的(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>)以及观察方向(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>)），输出是体密度(volumn density)以及该点在该视角下(view-dependent)的颜色估计值。我们合成视线的方法是通过查询从相机发出的光所经过的5D坐标，并用经典体渲染(volumn rendering)技术将输出的颜色和密度投影至2D照片。因为体渲染是可微分的，因此仅需要将带有相机位置的一系列图片作为输入。我们介绍了如何优化神经辐射场，并证明其结果优于先前的neural rendering和view synthesis方法。建议查看视频以对比。</p><h2 id="Introduction">Introduction</h2><p>函数会输出发出的辐射和密度(density)，密度是作为一个可微分的不透明度控制一道穿过(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>)的光线(ray)已经累积(accumulate)了多少辐射(radience)。我们的方法优化了一个全连接的深度网络，其不具有任何卷积层（通常被称为多层感知机MLP）。该网络代表了一个函数，从5D坐标回归(regress)至体密度和view-dependent的RGB值。</p><p>从该NeRF中渲染，我们需要：</p><ol><li>将相机光线穿过场景，它会经过一些3D点</li><li>将这些点以及它们的2D观察方向(viewing direction)作为神经网络的输入，生成颜色和密度</li><li>用经典体渲染技术累积这些值，生成2D图片</li></ol><p>这一过程是可微的，因此可通过梯度下降来减少误差（真实观察到的图片和我们生成的图片）。</p><p>我们发现基本的优化实现方式无法在高分辨率场景下收敛，并且出于其对于某具体光线要求的样本数量，十分低效。因此将5G坐标转换为坐标编码(positional encoding)以使MLP可以表示更高频的函数，并且我们提出了一种层级采样方法(hierarchical sampling procedure)用于减少所需的样本数。</p><p>我们的实现继承了volumetric representation的优点，都能表现复杂的真实场景，并且都适合梯度下降优化。重要的是，我们的办法克服了离散体素网格(discretized voxel grid)的高成本。</p><h2 id="Related-Work">Related Work</h2><p>计算机视觉领域中一种颇具前景的研究方向是将3D空间坐标直接映射到形状的隐式(implicit)表示，比如带符号的距离函数(signed distance function)。但在重现有复杂的高保真(fidelity)的几何图形的真实场景时，这些办法不如像三角网格(triangle mesh)或者体素网格(voxel grid)那些用离散表示的方法。</p><ul><li><p>Neural 3D shape reprensentation</p><p>通过隐式方法表示连续的3D形状，比如带符号的距离函数。这些模型被ground truth 3D geometry所限制。之后的工作将限制放宽至用2D图片进行优化。</p><p>虽然这些技术也能表示复杂的高分辨率的几何图形，但它们仍仅限于简单形状的使用</p></li><li><p>View synthesis and image-based rendering</p><p>一种方式是用基于网格的(mesh-based)表示方法。Differentiable rasterizer或者pathtracer可以通过梯度下降的方法直接优化网格表示法(mesh representation). 但是基于梯度的优化很难做到，并且这种策略需要模板网格，这在无限制的真实世界是无法实现的。</p><p>另一种方法是volumetric representation. 该方法可以表现复杂形状，并且很适合基于梯度优化，并且比基于网格的方式产生更少的artifact. 缺点是糟糕的时间和空间复杂度。而我们通过对连续的体积(continuous volumn)进行编码，不仅能有更高质量的渲染，还只需要之前的一部分存储开销。</p></li></ul><h2 id="Neural-Radiance-Field-Scene-Representation">Neural Radiance Field Scene Representation</h2><p>为使representation具有多视角一致性(multiview consistent)，对网络进行限制，使得密度仅是坐标的函数，而RGB color则是坐标和观察方向的函数。</p><h2 id="Volume-Rendering-with-Radiance-Fields">Volume Rendering with Radiance Fields</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以被理解为光线停止在x处的无穷小粒子的可微分概率，则光线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>o</mi><mo>+</mo><mi>t</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">r(t) = o + td</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span></span></span></span>产生的颜色<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>是：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><msub><mi>t</mi><mi>n</mi></msub><msub><mi>t</mi><mi>f</mi></msub></msubsup><mi>T</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>σ</mi><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>c</mi></mstyle><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>d</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(\pmb{r}) = \int^{t_f}_{t_n} T(t) \sigma(\pmb{r}(t)) \pmb{c}(\pmb{r}(t), \pmb{d})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4444em;vertical-align:-0.4559em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9885em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2901em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4559em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">))</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">c</span></span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">d</span></span><span class="mclose">)</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><msubsup><mo>∫</mo><msub><mi>t</mi><mi>n</mi></msub><mi>t</mi></msubsup><mi>σ</mi><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(t) = exp(-\int^t_{t_n} \sigma(\pmb{r}(s))ds)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4444em;vertical-align:-0.4559em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9885em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4559em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">))</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span>，代表光线不碰到从tn到t上的粒子的概率。</p><p>我们通过<a href="https://en.wikipedia.org/wiki/Quadrature_(geometry)">quadrature</a>的方法估算该积分。Deterministic quadrature会限制该representation的分辨率，因为MLP只需要一个固定的离散坐标列。因此采用分层采样法(stratified sampling approch)，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>f</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_n, t_f]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>分成N段，每段采一个点：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>∼</mo><mi>U</mi><mo stretchy="false">[</mo><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>N</mi></mfrac><mo stretchy="false">(</mo><msub><mi>t</mi><mi>f</mi></msub><mo>−</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><mfrac><mi>i</mi><mi>N</mi></mfrac><mo stretchy="false">(</mo><msub><mi>t</mi><mi>f</mi></msub><mo>−</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t_i \sim U[t_n + \frac{i-1}{N}(t_f - t_n), t_n + \frac{i}{N}(t_f - t_n)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2007em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8557em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2007em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8557em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)]</span></span></span></span></p><p>用这些采样点估算积分：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>C</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>δ</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>c</mi></mstyle><mi>i</mi></msub></mstyle></mrow><annotation encoding="application/x-tex">\hat{C}(\pmb{r}) = \displaystyle\sum_{i=1}^N T_i (1-exp(-\sigma_i \delta_i))\pmb{c}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.106em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mord"><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">c</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>σ</mi><mi>j</mi></msub><msub><mi>δ</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">T_i = exp(- \displaystyle\sum^{i-1}_{j=1} \sigma_j \delta_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\delta_i = t_{i+1} - t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8234em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="Optimizing-a-Neural-Radiance-Field">Optimizing a Neural Radiance Field</h2><p>两种优化方法，一种是对输入坐标进行positional encoding以协助MLP产生高频函数，另一种是hierarchical sampling procedure来有效采样高频的representation.</p><h3 id="Positional-encoding">Positional encoding</h3><p>尽管神经网络是通用函数模拟器(universal function approximator)，但实际上在高频部分表现不好。最近的研究表明更倾向于学习低频函数，此外，如果在传给网络前将输入先通过高频函数映射到更高维空间，则可以更好地拟合含有高频的数据。形式上，我们采用的encoding function:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>0</mn></msup><mi>π</mi><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>0</mn></msup><mi>π</mi><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>π</mi><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>L</mi><mo>−</mo><mn>1</mn></mrow></msup><mi>π</mi><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\gamma(p) = (sin(2^0 \pi p), cos(2^0 \pi p), \cdots, sin(2^{L-1} \pi p), cos(2^{L-1} \pi p))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">p</span><span class="mclose">))</span></span></span></span></p><p>该函数将分别作用于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>x</mi></mstyle></mrow><annotation encoding="application/x-tex">\pmb{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">x</span></span></span></span></span>的三个坐标分量以及观察方向单位向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>d</mi></mstyle></mrow><annotation encoding="application/x-tex">\pmb{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">d</span></span></span></span></span>的三个分量。</p><h3 id="Hierarchical-volome-sampling">Hierarchical volome sampling</h3><p>与其只用一个网络表示场景，我们同时使用粗粒度(coarse)和细粒度(fine)两个网络。</p><p>用之前的stratified sampling先采<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">N_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个点，初步估算颜色：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>c</mi></msub><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>c</mi></msub></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>c</mi></mstyle><mi>i</mi></msub></mstyle></mrow><annotation encoding="application/x-tex">\hat{C}_c(\pmb{r}) = \displaystyle\sum_{i=1}^{N_c} w_i \pmb{c}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1968em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1171em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8394em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3111em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal">c</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>σ</mi><mi>j</mi></msub><msub><mi>δ</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">w_i = T(i) exp(- \displaystyle\sum^{i-1}_{j=1} \sigma_j \delta_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2254em;vertical-align:-1.4138em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>之后再通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>w</mi><mo>^</mo></mover><mi>i</mi></msub><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mo>∑</mo><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\hat{w}_i = w_i / \sum{w_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>获得piecewise-constant PDF(probability distribution function)，并通过该概率密度函数用inverse transform sampling再次采样<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">N_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>个点。最后用这<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>c</mi></msub><mo>+</mo><msub><mi>N</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">N_c + N_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>个采样点一起输入到fine网络用于计算最终的颜色。这种方法的特点是非均匀地离散采样整个积分域。</p><h3 id="Implementation-details">Implementation details</h3><p>我们想要为每一个场景优化一个独立的神经连续volume representation网络。这需要捕获的RGB照片数据集，相对应的相机方位(pose)，内部参数(intrinsic parameters)，以及scene bound. 每一轮优化迭代中，从数据集的所有像素点随机采样一批(a batch of)相机光线，然后按照之前的hierarchical sampling，从coarse网络查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">N_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个点，从fine网络查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>c</mi></msub><mo>+</mo><msub><mi>N</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">N_c+N_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>个点，定义损失函数为：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munder><mo>∑</mo><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow></munder><mo stretchy="false">[</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>c</mi></msub><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mo>−</mo><mi>C</mi><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msubsup><mi mathvariant="normal">∣</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mover accent="true"><mi>C</mi><mo>^</mo></mover><mi>f</mi></msub><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mo>−</mo><mi>C</mi><mo stretchy="false">(</mo><mstyle style="text-shadow: 0.02em 0.01em 0.04px"><mi>r</mi></mstyle><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msubsup><mi mathvariant="normal">∣</mi><mn>2</mn><mn>2</mn></msubsup><mo stretchy="false">]</mo></mstyle></mrow><annotation encoding="application/x-tex">L = \displaystyle\sum_{r\in R}[||\hat{C}_c(\pmb{r}) - C(\pmb{r})||_2^2 + ||\hat{C}_f(\pmb{r}) - C(\pmb{r})||_2^2 ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3717em;vertical-align:-1.3217em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord">∣∣</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2329em;vertical-align:-0.2861em;"></span><span class="mord">∣∣</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord" style="text-shadow:0.02em 0.01em 0.04px;"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></p><p>这样既优化了最终fine网络的渲染结果，也减少了coarse网络的误差，这有助于后面在fine网络中采样。</p><h2 id="Results">Results</h2><p>采用RSNR/SSIM（越高越好），和LPIPS（越低越好）跟Neural Volumes, Scene Representation Networks, Local Light Field Fusion比较。</p><p>消融实验表明：</p><ol><li>positional encoding和view-dependence比hierarchical sampling提供了更多的好处。</li><li>就算为NeRF模型提供更少的照片也能比提供更多照片的NV, SRN, LLFF效果更好。</li><li>关于positional encoding所用到的最大频率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>，只用5个频率会降低性能，但用10到15个频率也不会增加性能。我们相信增加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>带来的好处在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">2^L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span></span></span></span></span></span></span></span>超过某范围时会受限。</li></ol><h2 id="Conclusion">Conclusion</h2><p>我们的工作通过MLP用连续函数表示物体和场景，解决了之前工作的一些缺陷。证明了将场景表示为5D神经辐射场比先前占支配地位的用深层卷积网络输出离散体素表示(discretized voxel representation)更加优秀。</p><p>尽管我们提出了层级采样策略，还有很多工作可以做。未来工作的一种方向是可解释性(interpretability)：sampled representation允许对渲染试图和故障模式的预期质量进行推理。</p><hr><p><strong>其他参考资料：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/569843149">都2022年了，我不允许你还不懂NeRF - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/380015071">Neural Radiance Fields (NeRF) - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/574351707">“图形学小白”友好的NeRF原理透彻讲解 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/659170662">一文带你入门NeRF：利用PyTorch实现NeRF代码详解（附代码） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2023/10/13/Git%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/13/Git%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Git笔记</h1><p><a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a></p><p><a href="E:%5CCS%5Cgit%5Cgitlab%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C.pdf">gitlab操作手册.pdf</a></p><h2 id="本地操作">本地操作</h2><p>分为三个区：工作区，暂存区（stage/index)，本地仓库（Repository)</p><p>一个文件在提交前共有四种状态：</p><p><img src="/2023/10/13/Git%E7%AC%94%E8%AE%B0/1-1697196793374-1.png" alt="四种状态"></p><blockquote><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93">Git - 记录每次更新到仓库 (git-scm.com)</a></p></blockquote><p>在上图中，通过add命令可将一个新的文件放入staged中（暂存区），之后通过commit提交至仓库（并变为unmodified)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt//可直接git add .以添加所有文件（追踪）</span><br><span class="line">git commit -m &#x27;add new file 1.txt&#x27;//注释</span><br></pre></td></tr></table></figure><p>如果在本地修改该文件，则将变为modified，此后要先通过add将之放入暂存区，才能commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt</span><br><span class="line">git commit -m &#x27;modify 1.txt&#x27;</span><br></pre></td></tr></table></figure><p>更便捷的方式直接提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &#x27;modify 1.txt&#x27;</span><br></pre></td></tr></table></figure><p>可以省下add，但要保证该文件已被追踪（即，新文件不能用这种方式直接提交）</p><hr><h3 id="查看状态：git-status">查看状态：<code>git status</code></h3><p>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s: 简要说明状态（用一个字母代指一个文件的状态）</span><br></pre></td></tr></table></figure><p>比如??是未追踪，A是新添追踪，M是修改，AM是它添加到缓存之后又有改动</p><hr><h3 id="比较差异：git-diff">比较差异：<code>git diff</code></h3><ul><li>尚未缓存的改动（已写入暂存区和已经被修改但尚未写入暂存区文件）：<code>git diff</code></li><li>查看已缓存的改动（缓存区和已提交）： <code>git diff --cached</code></li><li>查看已缓存的与未缓存的所有改动（上面两者）：<code>git diff HEAD</code></li><li>显示摘要而非整个 diff：<code>git diff --stat</code></li></ul><p>可接文件名以查看某个具体文件：<code>git diff -- 文件名</code></p><blockquote><p><a href="https://blog.csdn.net/qq_39505245/article/details/119899171">Git基础-git diff 比较文件的差异_NorthCastle的博客-CSDN博客</a></p><p><code>git diff</code>是工作区文件相比于缓存区</p><p><code>git diff HEAD</code>是工作区文件相比于HEAD处提交</p><p><code>git diff --cached</code>是缓存区文件相较于HEAD处提交</p><p><code>git diff 具体某版本</code>是工作区相较于该次提交</p><p><code>git diff --cached 具体版本号</code>是缓存区相较于该次提交</p></blockquote><hr><h3 id="回退版本：git-reset">回退版本：<code>git reset</code></h3><p>参考：<a href="https://blog.csdn.net/yaobao888/article/details/116108731">九、git reset详解_罗公子Coding的博客-CSDN博客</a></p><ul><li><code>git reset</code>：仅将index区回退至上次提交后（<code>--mixed</code>为默认参数）</li><li><code>git reset HEAD^</code>：仅将index和repository回退至上次提交后</li><li><code>git reset --soft HEAD^</code>：仅回退repository，适用于commit时有误想取消该commit</li><li><code>git reset --hard HEAD^</code>：三个区域均回退（慎用！！！）</li></ul><p>可以用多个^表示多个版本，也可以在~后跟数字（<code>HEAD</code>表示当前版本，<code>git reset HEAD</code>与<code>git reset</code>效果一致）</p><blockquote><p>可以通过版本号reset到未来版本（需通过<code>git reflog</code>获取之后的版本号）</p><p><code>git checkout -- filename</code>可以将工作区的文件回退到上次<code>git add </code>或者<code>git commit</code>时的状态</p></blockquote><hr><h3 id="删除文件：git-rm">删除文件：<code>git rm</code></h3><p>比起直接rm，这样做的好处是删除后不需要再commit了</p><p>以下实例从暂存区和工作区中删除 runoob.txt 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm runoob.txt </span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code></p><p>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached </code>选项</p><hr><h3 id="移动文件：git-mv">移动文件：<code>git mv</code></h3><p>好处是不需要add新建的文件。要删除要移动，在前面加git会方便很多</p><hr><h3 id="查看提交历史：git-log">查看提交历史：<code>git log</code></h3><p>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--oneline: 一条记录用一行显示</span><br><span class="line">--graph: 用色彩表示分支关系</span><br><span class="line">--reverse: 反过来显示（本来是早的在上，现在反过来）</span><br><span class="line">--since, --before, --until, --after</span><br></pre></td></tr></table></figure><p><code>git blame</code>以列表形式显示修改记录</p><hr><h2 id="远程操作：关联Github">远程操作：关联Github</h2><h3 id="密钥">密钥</h3><p>设置密钥参考：<a href="https://www.runoob.com/w3cnote/git-guide.html">Github 简明教程 | 菜鸟教程 (runoob.com)</a></p><h3 id="远程地址">远程地址</h3><p>成功收到欢迎界面后，添加远程地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure><p>上面命令中<code>origin</code>是对该地址的alias，可以用其他的，不过默认是这个（比如clone下来的本地仓库的remote就会被设置为origin)</p><blockquote><p><a href="https://www.zhihu.com/question/27712995/answer/2336292635">Git 里面的 origin 到底代表啥意思? - 知乎 (zhihu.com)</a></p></blockquote><blockquote><p>remote其余命令：</p><p>显示所有远程仓库：<code>git remote -v</code></p><p>显示某个远程仓库的信息：<code>git remote show [remote]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm name  # 删除远程仓库</span><br><span class="line">git remote rename old_name new_name  # 修改仓库名</span><br></pre></td></tr></table></figure></blockquote><h3 id="获取代码">获取代码</h3><p>从远程获取代码库：<code>git fetch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin//有多种写法</span><br></pre></td></tr></table></figure><blockquote><p>fetch后面的仓库名，分支名写法详见<a href="https://blog.csdn.net/QH_JAVA/article/details/77969010">git命令之git fetch的用法_苦咖啡-bit的博客-CSDN博客</a></p></blockquote><p>会将获取的版本记录到<code>FETCH_HEAD</code>中</p><h3 id="合并代码">合并代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [alias]/[branch]</span><br></pre></td></tr></table></figure><p>在fetch后可以直接执行<code>git merge</code>，此时默认将<code>FETCH_HEAD</code>合并至本地的当前分支</p><blockquote><p><a href="https://blog.csdn.net/QH_JAVA/article/details/77969010">git命令之git fetch的用法_苦咖啡-bit的博客-CSDN博客</a></p><p>合并代码的方法：</p><p>第一种，传统标准的做法：<br>git fetch origin 目标分支名 // fetch到远程仓库目标分支的最新commit记录到 ./git/FETCH_HEAD文件中<br>git checkout 要被合并的分支名 // 切换到要合并的分支<br>git merge FETCH_HEAD // 将目标分支最新的commit记录合并到当前分支</p><p>举例说明：将远程origin仓库的xx分支合并到本地的yy分支。<br>git fetch origin xx<br>git checkout yy<br>git merge FETCH_HEAD<br>完成。</p><p>如果关联了xx和yy（即<code>git push -u</code>)，则没必要在merge后加那个</p></blockquote><p>另一种方式是pull，但不推荐：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><blockquote><p>第二种，直接使用pull命令，将远程仓库的目标分支合并到本地的分支：<br>git pull &lt;remote_repository_name&gt; &lt;branch_name&gt;</p><p>举例说明：将远程origin仓库的xx分支合并到本地的yy分支：<br>git checkout yy<br>git pull origin xx<br>完成。</p><p>git pull 后不加参数的时候，跟git push 一样，默认就是git pull origin 当前分支名，当然远程仓库没有跟本地当前分支名一样的分支的话，肯定会报错。<br>本地master分支执行git pull的时候，其实就是git pull origin master。</p></blockquote><p>这两种方法的具体细节：<a href="https://blog.csdn.net/qq_34609889/article/details/88733153">Git fetch、pull以及merge之间的区别_pull和merge的区别_飞!!!的博客-CSDN博客</a></p><hr><blockquote><p><a href="https://www.runoob.com/w3cnote/git-guide.html">Github 简明教程 | 菜鸟教程 (runoob.com)</a></p><p>搞了半天终于明白上面这些fetch, pull, merge是获取最新的仓库，仅在远程版本领先时会生效。如果本地版本与其一致或者更新，则该命令无效。（不知道这里在写啥？可能当时是刚fetch过又fetch，此时远程还无其他更改，因此无效？）</p><p>这种情况下，如果想要回退本地版本至远程版本，可以使用<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p><p>fetch获得最新的版本，origin/master是FETCH_HEAD（reset必须跟HEAD名而不是仓库名）</p></blockquote><blockquote><p><a href="https://www.runoob.com/git/git-remote-repo.html">Git 远程仓库(Github) | 菜鸟教程 (runoob.com)</a></p><ul><li>执行 <code>git fetch origin master</code> 时，它的意思是从名为 <strong>origin</strong> 的远程上拉取名为 <strong>master</strong> 的分支到本地分支 <strong>origin/master</strong> 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。</li><li>执行 <code>git merge origin/master</code> 时，它的意思是合并名为 <strong>origin/master</strong> 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。</li><li>执行 <code>git push origin master</code> 时，它的意思是推送本地的 <strong>master</strong> 分支到远程 <strong>origin</strong>，涉及到远程以及分支，当然也得分开写了。</li><li>还可以一次性拉取多个分支的代码：<code>git fetch origin master stable oldstable</code>；</li><li>也还可以一次性合并多个分支的代码：<code>git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290</code>；</li></ul></blockquote><p>在合并改动之前，你可以使用如下命令预览差异：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><p>如：<code>git diff master origin/master</code></p><blockquote><p>HEAD代指当前分支，FETCH_HEAD代指远程分支，因此也可以<code>git diff HEAD FETCH_HEAD</code>，只是记得要先fetch到最新版本</p></blockquote><p>另一个命令是<code>git rebase</code>，其与<code>git merge</code>的区别：<a href="https://blog.csdn.net/xishining/article/details/115152823">Git：Rebase和Merge之间的区别，看完这篇文章你就懂了！_IT技术分享社区的博客-CSDN博客</a></p><hr><h3 id="推送代码">推送代码</h3><p><code>git push</code> 命令用于从将本地的分支版本上传到远程并合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure><p>删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>另外使用<code>-u</code>可以关联本地分支和远程分支</p><blockquote><p>© <code>git push -u</code>是将本地分支的更新推送到远程仓库，并将本地分支与远程分支关联的命令。其中，<code>-u</code>选项表示将本地分支与远程分支进行关联，这样在以后的推送和拉取操作中就可以省略分支名和远程仓库名，直接使用<code>git push</code>和<code>git pull</code>命令即可。</p><p>例如，如果要将本地分支<code>main</code>的更新推送到远程仓库<code>origin</code>的<code>main</code>分支，并与远程分支进行关联，可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>这样，在以后的推送和拉取操作中，就可以直接使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>而不需要再指定分支名和远程仓库名。</p></blockquote><p>如果本地版本低于远程版本，有如下方法：</p><ol><li>push前先将远程repository修改pull下来，然后再推送：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master </span><br><span class="line">...//做修改</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><ol start="2"><li>使用强制push的方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f </span><br></pre></td></tr></table></figure><p>这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。</p><ol start="3"><li>若不想merge远程和本地修改，可以先创建新的分支:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch [name] </span><br><span class="line">git push -u origin [name]</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/422024766">git push报错：Updates were rejected because the tip of your current branch is behind - 知乎 (zhihu.com)</a></p></blockquote><hr><h2 id="分支">分支</h2><p>创建分支命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>git checkout -b (branchname) </code>命令来创建新分支并立即切换到该分支下，从而在该分支中操作</p><blockquote><p>切换分支会影响工作区的文件，比如一个分支有1.txt，另一个没有，于是切换时会发现工作目录会变化。</p></blockquote><p>列出分支命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>删除分支命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>使用以下命令将任何分支合并到当前分支中去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge//不跟分支名则默认跟FETCH_HEAD，其他则要加上想要合并的分支名</span><br></pre></td></tr></table></figure><blockquote><p>当要合并的两个文件发生冲突时（比如master中1.txt和new中1.txt内容不同），需手动解决。</p><p>(Chat) 手动解决代码冲突通常需要执行以下步骤：</p><ol><li>打开你的代码编辑器，并切换到包含冲突的文件。</li><li>找到冲突的代码块，通常会有类似于 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>、<code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</code> 的标记，分别表示你当前分支的代码、两个分支的代码合并点和另一个分支的代码。</li><li>仔细检查冲突的代码块，并决定要保留哪些代码。你可以选择保留当前分支的代码、两个分支的代码合并点或另一个分支的代码，也可以将它们组合起来以创建新的代码。</li><li>一旦你决定了如何解决冲突，就可以手动编辑代码并删除冲突标记。</li><li>保存文件并提交你的更改。（实际上直接保存提交即可，但这样会多出些标记，因此还是删了后再提交）</li></ol><p>以下是一个示例代码冲突的解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">print(&quot;Hello, world!&quot;)</span><br><span class="line">=======</span><br><span class="line">console.log(&quot;Hello, there!&quot;);</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-branch</span><br></pre></td></tr></table></figure><p>在这个示例中，冲突的代码块包含两个 <code>print</code> 和 <code>console.log</code> 语句。你可以选择保留其中一个或两个，或者创建一个新的语句。例如，你可以将这些语句组合成一个输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello, world! Hello, there!&quot;);</span><br></pre></td></tr></table></figure><p>一旦你完成了解决冲突的代码块，就可以提交你的更改并继续合并分支。</p></blockquote><p>新建分支并将其push到origin去，需要添加<code>--set-upstream</code>参数</p><blockquote><p>©<code>--set-upstream</code> 是一个Git命令行选项，通常用于与远程仓库关联本地分支，并设置本地分支与远程分支的跟踪关系。这通常用于将本地分支推送到远程仓库的新分支，或者将本地分支与现有的远程分支进行关联。</p><p>下面是一些常见的情景和如何使用 <code>--set-upstream</code> 选项的示例：</p><ol><li><p><strong>创建新的本地分支并与远程分支关联</strong>：</p><p>假设你要创建一个新的本地分支并将其与远程仓库的分支关联。你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-feature-branch</span><br><span class="line">git push --set-upstream origin my-feature-branch</span><br></pre></td></tr></table></figure><p>这将创建一个名为 <code>my-feature-branch</code> 的本地分支，并将其推送到远程仓库（<code>origin</code>）的 <code>my-feature-branch</code> 分支上。<code>--set-upstream</code> 选项会自动建立跟踪关系。</p></li><li><p><strong>将本地分支与远程分支关联</strong>：</p><p>如果你已经有一个本地分支，但希望将其与远程分支关联，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/my-feature-branch my-feature-branch</span><br></pre></td></tr></table></figure><p>这将将本地的 <code>my-feature-branch</code> 分支与远程的 <code>origin/my-feature-branch</code> 分支关联起来。</p></li><li><p><strong>查看分支关联关系</strong>：</p><p>要查看本地分支与远程分支的关联关系，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><p>这会列出所有本地分支，并显示它们与远程分支的关联情况。</p></li></ol><p>总之，<code>--set-upstream</code> 选项是Git中用于建立本地分支与远程分支之间跟踪关系的有用工具，它使你能够更轻松地管理分支和与团队协作。</p></blockquote><p>之后在Github上会出现pull request, 同意即可在github上添加该分支</p><p>此外，合并时加与不加<code>--no-ff</code>的区别：<a href="https://blog.csdn.net/zombres/article/details/82179122">Git 合并时 --no-ff 的作用_git no-ff_zombres的博客-CSDN博客</a></p><h2 id="标签">标签</h2><p>希望记住某个特别的快照，使用<code>git tag</code>打标签</p><p>-a 选项意为&quot;创建一个带注解的标签&quot;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 </span><br></pre></td></tr></table></figure><p>假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以追加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.9 85fc7e7</span><br></pre></td></tr></table></figure><blockquote><p>commit后会生成一段哈希值，其前7位就可以作为唯一标识符。写完整版的也行。</p></blockquote><p>查看已有标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Git git]# git tag</span><br><span class="line">v1.0</span><br><span class="line">[root@Git git]# git tag v1.1</span><br><span class="line">[root@Git git]# git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Git git]# git tag -d v1.1</span><br><span class="line">Deleted tag ‘v1.1’ (was 91388f0)</span><br><span class="line">[root@Git git]# git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL笔记</title>
      <link href="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>OpenGL教程</h1><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2">OpenGL - YouTube</a></p><p>B站搬运链接：<a href="https://www.bilibili.com/video/BV1MJ411u7Bc/?vd_source=4b566ae72f027eb58b211581c0cfc339">最好的OpenGL教程之一_哔哩哔哩_bilibili</a></p><p>Github仓库链接：<a href="https://github.com/N0w13re/OpenGL">N0w13re/OpenGL (github.com)</a></p><blockquote><p>前三节没做笔记，可以参考：</p><p><a href="https://blog.csdn.net/qq_42741249/article/details/125732070">openGl新手入门学习笔记（一）什么是openGl，使用glfw库和环境搭建_opengl glfw_埃卡洛斯的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42741249/article/details/125737731">openGl新手入门学习笔记（二）下载glew，配置glew的环境与glew的初始化_埃卡洛斯的博客-CSDN博客</a></p></blockquote><h2 id="04-Vertex-Buffers-and-Drawing-a-Triangle">04 Vertex Buffers and Drawing a Triangle</h2><blockquote><p>在调整visual studio自动补全，遇到个问题是输入<code>unsigned</code>，当我按下<code>n</code>后<code>u</code>会被自动补全为<code>uint16</code>，搞半天才发现是成员列表提交字符那里我输入了enter…于是每次遇到这些字符都会触发补全</p><p>正确做法是删掉这些字符，回车键是默认的</p></blockquote><p>opengl是状态机，为生成的所有东西分配了唯一标识，是实际对象（顶点缓冲、顶点数组、纹理、着色器）的id，需要用这个对象时就调用这个id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;    </span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></table></figure><p>上述<code>buffer</code>就是id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer)</span><br></pre></td></tr></table></figure><p>该代码说明刚生成的buffer的用途</p><p>接下来既可以提供数据，也可以之后再提供。以下演示直接提供三角形数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><blockquote><p>这里教了在<a href="https://docs.gl/">docs.gl</a>中查阅函数参数，比如<code>glBufferData()</code>，通过该文档得知第二个参数以字节为单位，也得知参数<code>usage</code>中的static以及dynamic的区别</p></blockquote><p>接下来是绘制。由于还没学到着色器（shader），没有index buffer，因此借助<code>glDrawArrays()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLE, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230826114915802.png" alt="image-20230826114915802"></p><p>但这是不完整的，因此是黑屏输出</p><p>另一种绘制的函数是<code>glDrawElements()</code>，一般跟index buffer一起用，之后讲。</p><p>上述代码能绘制的原因在于之前有<code>glBindBuffer()</code>绑定了，若绑错了就会绘制到其他“图层”上去</p><hr><h2 id="05-Vertex-Attributes-and-Layouts">05 Vertex Attributes and Layouts</h2><p>首先要区分vertex和position是不同的，vertex是点，坐标只是它的一个attribute</p><p>指定attribute时需调用函数<a href="https://docs.gl/gl4/glVertexAttribPointer">glVertexAttribPointer()</a>，告诉OpenGL如何解释和处理顶点数据。下面介绍其参数：</p><ul><li>index: 所需修改的attribute是第几个，比如可以规定坐标是第0个，颜色是第1个，法线（normal）是第2个……</li><li>size: 每个属性的组件数量，比如之前的每个坐标就有2个分量</li><li>type: 略</li><li>normalized: 将0-255规约至0-1</li><li>stride: buffer中一个vertex所有属性的字节大小和</li><li>position: 略，注意此position已经在顶点中了</li></ul><p>例如，上述第一个vertex的第一个属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>如果要第二个属性可以将<code>position</code>参数改为<code>(const int *)4</code></p></blockquote><p>此外还需在其前加上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过这两行代码，就告诉了opengl我们的buffer的layout是什么样的</p><hr><h2 id="06-How-Shaders-Work">06 How Shaders Work</h2><p>着色器用于处理传入的数据，最流行的两种shader：vertex shader, fracture shader, 后者又称为pixel shader</p><p>rendering pipeline is how do we go from having data to actually having results on the screen</p><p>当我们发出draw call时，vertex shader, fracture shader先后被调用</p><p>vertex shader告诉opengl想在哪里绘制这三个点，这样opengl才能在屏幕上找到对应坐标。每个vertex调用一次。</p><p>fracture shader作用是告诉opengl三角形中每个像素点的颜色，用于之后rasterization stage中的rasterize（光栅化，也就是实际绘制该像素点）。每个像素点调用一次。</p><hr><h2 id="07-Writing-a-Shader">07 Writing a Shader</h2><p>首先是创建shader的函数接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fractureShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来完成CompileShader():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();<span class="comment">//亦可写作&amp;source[0]，总之指向数据区首字节地址</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);<span class="comment">//Replaces the source code in a shader object</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> ERROR handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后继续完成CreateShader()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);<span class="comment">//由于已经link到program上了，中间产物(intermediates)可以删掉</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来完善CompileShader()中的TODO:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);<span class="comment">//https://docs.gl/gl4/glCompileShader中有提及用该函数验证</span></span><br><span class="line">    <span class="keyword">if</span> (!result)<span class="comment">//可以是result == GL_FALSE, 不过GL_FALSE等于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span> *message = (<span class="type">char</span> *)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to Compile &quot;</span> &lt;&lt;</span><br><span class="line">            (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>alloc()</code>函数是在栈上分配空间，详情参考<a href="https://blog.csdn.net/lingling_1/article/details/47445273">malloc、calloc、realloc、new以及alloca函数区别_malloc new alloca_勇敢无畏的活着的博客-CSDN博客</a></p><p>此后在<code>main()</code>函数中调用<code>CreateShader()</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::string vertexShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span><span class="comment">//version 330:没用更新的版本是因为暂时不需要那么复杂</span></span><br><span class="line">    <span class="comment">//core表示不使用deprecated的函数</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span><span class="comment">//0是index of attribute</span></span><br><span class="line"><span class="comment">//至于为什么是vec4而不是vec2?因为之后gl_Position是vec4，就算这里用了vec2之后也得用vec4(position.xy,0,0)去扩展</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;gl_Position = position;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string fragmentShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;color = vec4(1.0, 0.0, 0.0, 1.0);\n&quot;</span><span class="comment">//rgba</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/suyimin2010/article/details/99700711">layout(location=0) in vec4 vPosition_layout(location = 0) in vec4 position;_Luckie stone的博客-CSDN博客</a></p><ol><li><p>vPosition指变量名称，它所保存的是顶点的位置信息</p></li><li><p>vec4是GLSL中的一种数据类型，在这里表示GLSL的四维浮点数向量，默认值为(0,0,0,1)，表示(x,y,z,w)。当有字段缺失时，会填充对应的默认值。</p></li><li><p>in字段的话，表示设置这个变量，即vPosition为着色器阶段的输入变量，指定了数据进入着色器的流向，在这里代表数据从外部流入。</p></li><li><p>layout(location=0)，这一字段非常重要，它将vPosition的位置属性location设置为0，为它提供了元数据。</p></li></ol></blockquote><blockquote><p><a href="https://blog.csdn.net/hankern/article/details/89325452">openGL之API学习（四十七）layout作用详解_glsl layout-CSDN博客</a></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="keyword">attribute</span> <span class="keyword">index</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br></pre></td></tr></table></figure><p>可以指定顶点着色器输入变量使用的顶点属性索引值，一般在glVertexAttribPointer中指定属性索引值。如果同时使用了glBindAttribLocation，那么这个layout优先。</p></blockquote><blockquote><p>©<code>position</code> 是这个顶点着色器中定义的一个输入变量，通常用于表示顶点的位置信息。下面是对 <code>position</code> 变量的详细解释：</p><ol><li><p><strong>变量类型</strong>：<code>position</code> 被定义为 <code>vec4</code> 类型的变量。<code>vec4</code> 是GLSL中的一种矢量类型，表示一个包含四个分量的向量。通常，顶点的位置可以由一个三维向量 (x, y, z) 表示，但在这里使用了一个四维向量，通常情况下第四个分量（通常是w）被用于进行坐标变换和投影。</p></li><li><p><strong>输入变量</strong>：<code>position</code> 是一个输入变量，因为它以 <code>in</code> 关键字定义。这意味着 <code>position</code> 的值将由渲染管道的前阶段（通常是应用程序代码）提供给顶点着色器。这通常是从顶点缓冲对象（VBO）中读取的顶点数据。</p></li><li><p><strong>位置属性</strong>：通常情况下，<code>position</code> 变量用于表示顶点在模型坐标系中的位置。这是指顶点相对于模型的局部坐标系的位置，还没有经过任何变换。在顶点着色器中，您可以对这些位置进行变换，以将它们转换到世界坐标系、相机坐标系和裁剪空间，从而最终在屏幕上进行渲染。</p></li><li><p><strong>用途</strong>：<code>position</code> 变量通常用于将顶点的位置信息传递给图形渲染管道的后续阶段，特别是裁剪阶段和视口变换阶段。在这些阶段，它将经过一系列的变换和处理，最终确定每个顶点在屏幕上的位置。</p></li></ol><p>总之，<code>position</code> 是顶点着色器中用于表示顶点位置的输入变量，它是一个四维向量，通常表示顶点在模型坐标系中的位置，而在顶点着色器中，您可以对这些位置进行各种变换，以便进行后续的渲染操作。</p></blockquote><blockquote><p>该段GLSL与之前<code>glVertexAtttibPointer()</code>的联系：<a href="https://blog.csdn.net/weixin_37459951/article/details/96433508">OpenGL glVertexAttribPointer（）函数解析_soft_logic的博客-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</p></blockquote><blockquote><p>总结下，<code>layout</code>那句是GLSL的声明，声明position这个变量，并使其获得属性位置0处的数据；而<code>glVertexAttribPointer</code>是定义从GL_ARRAY_BUFFER传数据进入shader的方式，比如给属性位置0处传入代表坐标的positions数组</p></blockquote><p>编译生成得到红色三角形。如果去掉color后的分号，拿去编译，会提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to Compile fragmentshader!</span><br><span class="line">ERROR: 0:4: &#x27;void&#x27; : syntax error syntax error</span><br></pre></td></tr></table></figure><p>表示我们的错误处理代码正确</p><p>此外，最后应加上清除代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br></pre></td></tr></table></figure><hr><h2 id="08-How-Do-I-Deal-with-Shaders">08 How Do I Deal with Shaders</h2><p>该节讲述了如何将上述shader代码独立成文件</p><p>新建<code>res\shaders\Basic.shader</code>，写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#shader vertex</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec4 position;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一开始没弄对，新建的是筛选器，筛选器只是表面上的分类，实际并未新建文件夹。需要点击“显示所有文件”，之后才能新建文件夹</p><p><a href="https://www.cnblogs.com/Kit-L/p/13888534.html">VisualStudio如何在解决方案里添加真实的文件夹而不是虚的解决方案文件夹 - Kit_L - 博客园 (cnblogs.com)</a></p></blockquote><p>此后在主文件中添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">    &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != <span class="number">-1</span>)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != <span class="number">-1</span>)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;<span class="comment">//str()将stringstream转为string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>stringstream</code>参考<a href="https://blog.csdn.net/liitdar/article/details/82598039">C++编程语言中stringstream类介绍_liitdar的博客-CSDN博客</a></p><p>此后在<code>main()</code>中调用<code>ParseShader()</code>并测试（需删去后面跟shader有关的函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source = <span class="string">&quot;/res/shaders/Basic.shader&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; source.VertexSource &lt;&lt; std::endl;</span><br><span class="line">Std::cout &lt;&lt; source.FragmentSource &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>报错：</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230902215629770.png" alt="image-20230902215629770"></p><p>将<code>ParseShader()</code>中参数前加上<code>const</code>即可</p></blockquote><p>最后版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br></pre></td></tr></table></figure><hr><h2 id="09-Index-Buffers">09 Index Buffers</h2><p>如何画个正方形？将其看做两个三角形，因此需要修改如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>缺点是<code>position</code>数组中有重复点，因此需要index buffer来复用</p><p>删去<code>position</code>数组中重复点，添加index buffer如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,   <span class="comment">//0</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,   <span class="comment">//1</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,   <span class="comment">//2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>    <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;<span class="comment">//必须unsigned</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仿照之前的buffer，另外创建绑定index buffer:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);<span class="comment">//第一个参数不同</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>将while循环内的<code>glDrawArrays()</code>改为<code>glDrawElements()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);<span class="comment">//6是indices中元素个数；最后的参数是pointer to index buffer，由于之前已经将index buffer绑定在GL_ELEMENT_ARRAY_BUFFER，因此不需要放指针</span></span><br></pre></td></tr></table></figure><hr><h2 id="10-Dealing-with-Errors">10 Dealing with Errors</h2><p>两种函数常用语处理错误，<code>glGetError()</code>与<code>glDebugMessageCallback()</code>，后者功能更强但仅支持4.3版本及之后。本节内容主要关注前者。根据<a href="https://docs.gl/gl4/glGetError">glGetError - OpenGL 4 - docs.gl</a>:</p><blockquote><p>To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to <code>GL_NO_ERROR</code> when <code>glGetError</code> is called. If more than one flag has recorded an error, <code>glGetError</code> returns and clears an arbitrary error flag value. Thus, <code>glGetError</code> should always be called in a loop, until it returns <code>GL_NO_ERROR</code>, if all error flags are to be reset.</p></blockquote><p>必须在循环中调用。</p><p>在开头添加函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后将原来<code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</code>中的<code>GL_UNSIGNED_INT</code>改为<code>GL_INT</code>，同时在前后添加上述两个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">GLCheckError</span>();</span><br></pre></td></tr></table></figure><p>运行可以得到1280的错误信息</p><p>将其通过打断点的方式转为十六进制0x500，在glew.h中搜索<code>0x0500</code>，可得<code>#define GL_INVALID_ENUM 0x0500</code></p><p>然而这样的方式是在已知错误语句的情况下完成的，显然不符需要。因此采用断言</p><p>首先将<code>GLCheckError()</code>改为返回bool类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在开头添加宏<code>#define ASSERT(x) if (!(x)) __debugbreak();</code></p><p>将<code>GLCheckError()</code>改为<code>ASSERT(GLLogCall());</code>，运行后循环一次就会停下</p><blockquote><p><code>__debugbreak()</code>仅在MSVC环境下支持，clang等不支持</p></blockquote><p>继续添加宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\<span class="comment">//注意\表示该行未结束，后面不能有空格</span></span></span><br><span class="line">    x;\</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">GLLogCall</span>())</span><br></pre></td></tr></table></figure><p>即可将之前的三句指令简化为<code>GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));</code></p><p>多文件下想要快速定位出问题的地方，可以在<code>GLLogCall()</code>添加参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *function, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将宏改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">    ASSERT(GLLogCall(#x, __FILE__, __LINE__))<span class="comment">//#将后面的宏参数进行字符串</span></span></span><br></pre></td></tr></table></figure><p>再次运行代码，就能定位出具体哪里出的bug</p><p>此后要做的就是，每个调用OpenGL函数的地方都加上<code>GLCall()</code></p><blockquote><p>有提到上面这种宏会有flaw（缺陷），当x是在单行if语句时，在两侧加上<code>GLCall()</code>，则仅有第一行代码会在if语句中。解决方案是采用scope或者do while循环</p><blockquote><p>并不是很明白为什么那样会出问题，搜了下发现c++17后多了个init-statement，但不知道有何联系（？）</p><p><a href="https://blog.csdn.net/yangsenuestc/article/details/79841515">C++17新特性(2) – if/switch初始化(Init statement for if/switch)_c++17 新特性 if 定义_yangsenUCAS的博客-CSDN博客</a></p></blockquote><p>但用scope的方法（就是加花括号）又会有别的问题，比如<code>unsigned int id = glCreateShader(type);</code>，若我们在其两侧加了花括号，将导致之后的id均无法使用（因为id在scope内）</p></blockquote><hr><h2 id="11-Uniforms">11 Uniforms</h2><p>uniform是从cpu获取数据到shader的一种方式，可以被当作变量使用。uniform每次绘制都需要设置。</p><p>将fragment shader部分改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在main函数<code>glUseProgram()</code>后添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>));</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><blockquote><p>（C)这段代码看起来是使用OpenGL进行着色器参数设置的代码片段。让我们逐行进行分析：</p><ol><li><p><code>GLCall(int location = glGetUniformLocation(shader, &quot;u_Color&quot;));</code></p><p>这一行代码调用了一个名为 <code>GLCall</code> 的函数，它的作用是用来检查OpenGL函数调用是否出错，并返回函数调用的结果。这里调用了 <code>glGetUniformLocation</code> 函数，该函数用于获取着色器程序中 uniform 变量的位置（location）。它的参数 <code>shader</code> 是着色器程序的句柄，而 <code>&quot;u_Color&quot;</code> 是要获取位置的 uniform 变量的名称。如果找不到该名称的 uniform 变量，<code>glGetUniformLocation</code> 将返回 -1。</p></li><li><p><code>ASSERT(location != -1);</code></p><p>这一行代码使用了一个断言，用于检查 <code>glGetUniformLocation</code> 返回的 <code>location</code> 是否不等于 -1。如果 <code>location</code> 等于 -1，这意味着无法找到名称为 “u_Color” 的 uniform 变量，可能是由于名称拼写错误或者该变量在着色器程序中不存在。断言用于在这种情况下终止程序的执行，以便及早发现问题。</p></li><li><p><code>GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</code></p><p>这一行代码使用 <code>glUniform4f</code> 函数来设置名为 “u_Color” 的 uniform 变量的值。它接受 <code>location</code>（在前一行获取的）作为第一个参数，然后将一个四维向量 (0.2f, 0.3f, 0.8f, 1.0f) 分配给该 uniform 变量。这将改变该 uniform 变量在着色器程序中的值，影响着色器的渲染结果。</p></li></ol><p>总的来说，这段代码的作用是设置着色器程序中的一个 uniform 变量 “u_Color” 的值为 (0.2f, 0.3f, 0.8f, 1.0f)，并且在找不到该 uniform 变量或者其他OpenGL调用错误时进行错误检查和处理。注意，可能存在与 <code>GLCall</code> 和 <code>ASSERT</code> 相关的宏定义或函数实现，以执行错误检查和处理的具体逻辑，但这里的代码片段并未包含这些定义或实现。</p></blockquote><p>再做出如下改动：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>));</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是在蓝和粉之间跳跃。因为红通道在0和1之间跳跃。</p><p>在<code>glfwMakeContext();</code>后加上<code>glfwSwapInterval(1);</code>，用于开启图形渲染的垂直同步</p><blockquote><p><code>glfwSwapInterval</code> 是 GLFW 库中的函数，用于控制垂直同步（Vertical Synchronization，简称V-Sync）的行为。V-Sync 是一种图形渲染技术，用于防止图像撕裂（tearing），同时将帧速率与显示器的刷新率同步。</p><p>以下是有关 <code>glfwSwapInterval</code> 函数的详细信息：</p><ol><li><p><strong>函数签名</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glfwSwapInterval</span><span class="params">(<span class="type">int</span> interval)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>功能</strong>：</p><ul><li><code>glfwSwapInterval</code> 用于控制图形渲染的垂直同步。</li><li><code>interval</code> 参数指定了要设置的垂直同步模式。通常情况下，它可以是以下之一：<ul><li>0：禁用垂直同步，允许无限制地渲染帧，可能会导致撕裂。</li><li>1：启用垂直同步，将渲染帧与显示器的刷新率同步，防止撕裂。</li></ul></li></ul></li></ol><p>垂直同步对于控制帧速率以及提高图形渲染的平滑度非常有用，特别是在游戏和图形应用程序中。</p></blockquote><blockquote><p>Q: 如何更改使得长方形沿对角，分别显示两种不同的颜色？</p><p>C: 要使长方形沿对角线分别显示两种不同的颜色，你可以在顶点数据中添加颜色信息，并在着色器中根据顶点的位置来插值颜色。以下是如何修改你的代码来实现这个效果的步骤：</p><ol><li><p>修改顶点数据：</p><p>首先，你需要修改顶点数据以便每个顶点都有一个颜色属性。为了使矩形沿对角线分别显示两种不同的颜色，你可以为每个顶点分配不同的颜色值。这里，我们假设你要使用红色和绿色两种颜色，可以修改你的 <code>positions</code> 数组和顶点属性的设置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置               // 颜色</span></span><br><span class="line">   <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角，红色</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下角，绿色</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右上角，蓝色</span></span><br><span class="line">   <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 左上角，黄色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们在每个顶点后面添加了颜色属性，每个顶点有五个值：x坐标、y坐标、红色分量、绿色分量和蓝色分量。</p></li><li><p>修改顶点属性指针：</p><p>在你的代码中，你需要修改顶点属性指针来正确处理颜色数据。在 <code>GLCall(glVertexAttribPointer(...))</code> 调用中，修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>))));</span><br></pre></td></tr></table></figure><p>这里，我们启用了第一个属性（位置属性）和第二个属性（颜色属性），并通过 <code>glVertexAttribPointer</code> 指定了它们的属性大小和偏移量。位置属性有两个浮点数（x和y坐标），所以属性大小是2，颜色属性有三个浮点数（红色、绿色和蓝色分量），所以属性大小是3。颜色属性的偏移量为 <code>2 * sizeof(float)</code>，因为位置属性占据了前两个浮点数的空间。</p></li><li><p>修改着色器：</p><p>在着色器中，你需要接收颜色属性并在片段着色器中插值它们。以下是修改着色器的示例：</p><p>顶点着色器（<code>Basic.shader</code> 中的内容）：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">                  </span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> a_Position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> a_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> v_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(a_Position, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    v_Color = a_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器（<code>Basic.shader</code> 中的内容）：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">                  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> v_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line">                  </span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(v_Color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们在顶点着色器中接收颜色属性并将它传递到片段着色器中，然后在片段着色器中使用颜色属性设置片段颜色。</p></li></ol><p>完成这些步骤后，你的长方形应该沿对角线分别显示红色和绿色，因为你在每个顶点上指定了不同的颜色值。希望这能帮助你实现你的目标！</p></blockquote><hr><h2 id="12-Vertex-Arrays">12 Vertex Arrays</h2><p><code>glVertexAttribPointer()</code>并不是跟缓冲区绑定在一起的（并非存储在buffer中），而是跟vertex array object绑定在一起的。</p><p>为做测试，先在while循环前解绑所有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>将while循环改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可得到相同结果。问题是，每次都需要<code>glEnableVertexAttribArray(0)</code>以及<code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0)</code>吗？答案是是的，因为可能下次画的时候layout就不同了。而vertex array object恰好包含这个信息，如果我们为每个要绘制的图形创建一个顶点数组对象，则对于每次绘制，我们仅需要绑定顶点数组对象。因为VAO包含vertex buffer与实际的vertex specification或者说vertex layout间的绑定；换句话说<code>glVertexAttribPointer()</code>会绑定vertex buffer和array buffer(GL_ARRAY_BUFFER)。OpenGL compatability profile会默认为我们创建VAO，但core profile不会，因此需要我们手动创建。</p><blockquote><p><a href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object">Vertex_Array_Object</a></p><p>The compatibility OpenGL profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all. So if VAO 0 is bound in the core profile, you should not call any function that modifies VAO state. This includes binding the <code>GL_ELEMENT_ARRAY_BUFFER</code> with <a href="https://www.khronos.org/opengl/wiki/GLAPI/glBindBuffer">glBindBuffer</a>.</p><blockquote><p>©在OpenGL中，VAO（Vertex Array Object）是一种用于管理顶点数据和渲染状态的对象。OpenGL有两种不同的配置文件（profile）：兼容性（compatibility）配置文件和核心（core）配置文件。这两个配置文件的行为在某些方面有所不同。</p><ol><li><p><strong>兼容性OpenGL配置文件</strong>：在兼容性配置文件中，VAO对象0被视为默认对象。这意味着如果没有显式绑定VAO，OpenGL将使用默认的VAO对象0。在此配置文件中，可以调用一些函数来修改VAO对象0的状态，包括绑定<code>GL_ELEMENT_ARRAY_BUFFER</code>。</p></li><li><p><strong>核心OpenGL配置文件</strong>：在核心配置文件中，VAO对象0不被视为对象。这意味着VAO对象0在核心配置文件中不可用。如果尝试在核心配置文件中绑定VAO对象0，应该避免调用任何会修改VAO状态的函数，包括绑定<code>GL_ELEMENT_ARRAY_BUFFER</code>。</p></li></ol><p>简而言之，兼容性OpenGL配置文件允许VAO对象0的使用，并允许在其上进行状态更改操作，而核心OpenGL配置文件禁用了VAO对象0，因此在核心配置文件中不应该对其进行任何操作。这是OpenGL版本之间的一个重要差异，需要根据所使用的配置文件来谨慎管理VAO对象的状态。</p></blockquote></blockquote><p>在<code>glfwCreateWindow()</code>前添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure><p>此时会将版本号调整为3.3，并用core profile，运行，就会在<code>glEnableVertexAttribArray()</code>报错，1282(=0x00000502)，在glew.h中搜索0x0502可知这是<code>GL_INVALID_OPERATION</code>，再从<a href="https://docs.gl/gl4/glEnableVertexAttribArray">glEnableVertexAttribArray - OpenGL 4 - docs.gl</a>得知，这是因为没有VAO被绑定。（确切的说，根据<a href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object">Vertex_Array_Object</a>，core profile根本就没有VAO 0)</p><p>在<code>glBindBuffer()</code>前添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao));</span><br></pre></td></tr></table></figure><p>再度运行，成功。</p><p>更进一步，将while循环改成：（对比起见，在解绑的三条指令前添加<code>GLCall(glBindVertexArray(0))</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在while循环中删去了一些指令，只剩下绑定vao以及index buffer，但效果与之前相同。</p><p>解释：<code>glBindVertexArray(vao)</code>以及<code>glBindBuffer(GL_ARRAY_BUFFER, buffer)</code>并没有将二者连接起来，但<code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0)</code> makes index 0 of this vertex array be bound to GL_ARRAY_BUFFER.</p><blockquote><p>不知道啥意思，总之就是这条指令连接了VAO与VBO(vertex buffer object, 也即buffer变量对应的对象)</p></blockquote><p>如果将<code>glVertexAttribPointer()</code>的第一个参数改为1, 那么vao的index 1会指向其他buffer.</p><blockquote><p>实际上也可以将index buffer绑定在vao上</p></blockquote><p>大型项目的两种做法：一种是就只要一个vao，每次绑定不同的buffer；另一种是每个geometry都设置一个vao. 各有优劣，依实际选择。</p><hr><h2 id="13-Abstracting-into-Classes">13  Abstracting into Classes</h2><p>将错误处理部分单独提出来作为Renderer.cpp以及Renderer.h</p><p>将生成GL_ARRAY_BUFFER的部分提出来作为VertexBuffer.cpp以及.h</p><p>将生成GL_ELEMENT_ARRAY_BUFFER的部分作为IndexBuffer.cpp以及.h</p><blockquote><p>在生成index buffer的时候，将参数从vertex buffer的<code>const void* </code>改为<code>const unsigned int* </code>，<code>size</code>改为<code>count</code>，因为<code>size</code>一般是作为字节数，而这里已经声明了是<code>unsigned int</code>，则应该传入其个数<code>count</code></p></blockquote><p>修改Application.cpp后运行，仍能弹出矩形，但关闭窗口后，命令台并不会退出。点击暂停调试，查看堆栈：</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230923114142560.png" alt="image-20230923114142560"></p><p>这是因为程序退出时要运行析构函数，但在<code>return 0</code>前就已经有<code>glfwTerminate()</code>，摧毁了OpenGL context. 此时由于失去context，<code>GLGetError()</code>就会一直报错</p><p>我们可以通过new与delete手动调用解构，不过这里用scope的方式，加花括号。</p><hr><h2 id="14-Buffer-Layout-Abstraction">14 Buffer Layout Abstraction</h2><p>VAO的作用是将vertex buffer以及其layout整合在一起</p><p>本节将vertex buffer, index buffer, vertex buffer layout以及最主要的vertex array分别抽象出来为单独的文件</p><hr><h2 id="15-Shader-Abstraction">15 Shader Abstraction</h2><p>将Shader抽象出Shader.cpp及.h</p><hr><h2 id="16-Writing-a-Basic-Renderering">16 Writing a Basic Renderering</h2><p>在Renderer.h中添加Renderer类并加入成员函数<code>Draw()</code></p><p>不过在编译时出现如下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">严重性代码说明项目文件行禁止显示状态</span><br><span class="line">错误C3861“ASSERT”: 找不到标识符OpenGLD:\Projects\OpenGL\OpenGL\src\VertexBufferLayout.h20</span><br></pre></td></tr></table></figure><p>但打开VertexBufferLayout.h会看到我们包含了Renderer.h文件，而Renderer.h中有ASSERT的宏定义</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230926142756700.png" alt="image-20230926142756700"></p><p>究其原因，此时我们在LayoutBuffer.h中<code>#include &quot;Renderer.h&quot;</code>，又在Renderer.h中<code>#include &quot;VertexArray.h&quot;</code>（包含这个是因为<code>Draw</code>函数需要使用），而VertexArray.h中有<code>#include &quot;VertexBufferLayout.h&quot;</code>，如此导致循环包含，这种情况会导致编译器陷入无限循环，因为它无法确定要包含的头文件的顺序。</p><p>此处采用的方法是将VertexArray.h添加<code>class VertexBufferLayout;</code>，并在VertexBuffer.cpp中加入<code>#include &quot;VertexBufferLayout.h&quot;</code></p><blockquote><p>©在VertexArray.h这段代码中，<code>class VertexBufferLayout;</code> 是一个前置声明（forward declaration）。前置声明是一种告诉编译器某个类或类型将在稍后的代码中定义的方式。它告诉编译器有关类 <code>VertexBufferLayout</code> 的基本信息，但不提供关于类的详细定义。这种声明通常用于解决循环依赖或仅需要知道类型的名称而不需要知道其内部结构的情况。</p><p>在这里，<code>VertexArray</code> 类中使用了 <code>VertexBufferLayout</code> 类的对象作为参数，但它并没有包含 <code>VertexBufferLayout.h</code> 的头文件。相反，它只是在类定义之前声明了 <code>VertexBufferLayout</code> 类。这允许编译器在编译此文件时知道 <code>VertexBufferLayout</code> 类的名称和基本信息，而不需要了解其详细定义。然后，在其他地方的代码中，你需要包含 <code>VertexBufferLayout.h</code> 头文件，以获得关于 <code>VertexBufferLayout</code> 类的实际定义。</p><p>这种前置声明有助于减少编译时间，特别是在大型代码库中，因为它可以减少不必要的头文件包含。但请确保在使用 <code>VertexBufferLayout</code> 类的任何实际功能之前，你必须包含相关的头文件以获取完整的定义。</p></blockquote><blockquote><p>弹幕说这种方式对于大型项目是危险的，正确处理方式是将宏定义单独写在一个头文件中</p></blockquote><p>完成后，此时每次渲染前仍需绑定shader以及指定uniform，这很麻烦，因此我们需要学习material. material就是renderer+shaders.</p><hr><h2 id="17-Textures">17 Textures</h2><p>新建Texture.h，输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">std::string m_FilePath;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* m_LocalBuffer;</span><br><span class="line"><span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>Bind()</code>需要加参数slot是因为可同时绑定多个texture，在windows上一般是32个，而手机上一般就只有8个（取决于GPU）</p><p>在<code>Texture</code>类的构造函数中添加<code>stbi_set_flip_vertically_on_load(1);</code>，因为OpenGL希望texture从左下角开始，左下角是(0,0). 而PNG是从上到下的，所以应当flip. 此后的<code>m_LoadBuffer = stbi_load(path.c_str(), &amp;m_Width, &amp;m_Height, &amp;m_BPP);</code>函数创建了加载texture的buffer.</p><p>在构造函数中创建Texture，并规定参数：</p><pre><code>GLCall(glGenTextures(1, &amp;m_RendererID));GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));</code></pre><blockquote><p>©这里的代码执行了一系列OpenGL函数调用，用于设置纹理对象的参数，具体如下：</p><ol><li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</code>：设置2D纹理的缩小过滤器（minification filter）为线性过滤（GL_LINEAR）。这意味着当纹理被缩小时，OpenGL会使用线性插值来计算像素颜色。</li><li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</code>：设置2D纹理的放大过滤器（magnification filter）为线性过滤（GL_LINEAR）。这意味着当纹理被放大时，OpenGL会使用线性插值来计算像素颜色。</li><li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)</code>：设置2D纹理的水平包裹模式（wrap mode）为GL_CLAMP，这意味着当纹理坐标超出[0,1]的范围时，OpenGL会使用边缘的纹理像素颜色。</li><li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)</code>：设置2D纹理的垂直包裹模式（wrap mode）为GL_CLAMP，与上一行类似，这意味着当纹理坐标超出[0,1]的范围时，OpenGL会使用边缘的纹理像素颜色。</li></ol></blockquote><p>接下来将buffer中数据传给texture:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));</span><br></pre></td></tr></table></figure><blockquote><p>第三个参数Internal_format是数据在内存中的数据格式，倒数第二个参数format则是传给OpenGL的数据格式</p><ul><li><code>GL_TEXTURE_2D</code>：指定了目标纹理类型，这里是2D纹理。</li><li><code>0</code>：指定了纹理的层级（level）。通常，0表示基本的纹理级别。</li><li><code>GL_RGBA8</code>：指定了纹理的内部格式（internal format）。在这里，它表示纹理内部存储的像素数据使用RGBA通道，每个通道占8位（一个字节）。</li><li><code>m_Width</code>：纹理的宽度（以像素为单位）。</li><li><code>m_Height</code>：纹理的高度（以像素为单位）。</li><li><code>0</code>：指定了边框的宽度。通常情况下，这是0。</li><li><code>GL_RGBA</code>：指定了源图像数据的格式，这里是RGBA格式。</li><li><code>GL_UNSIGNED_BYTE</code>：指定了源图像数据的数据类型，这里是无符号字节数据类型。</li><li><code>m_LocalBuffer</code>：包含纹理像素数据的指针，这是你要加载到纹理中的图像数据。</li></ul><p>这行代码的目的是将 <code>m_LocalBuffer</code> 中的图像数据加载到2D纹理对象中，并指定了有关纹理的各种参数，包括纹理的大小、格式等。这样，在渲染时，你可以将这个纹理绑定到一个纹理单元并使用它来渲染物体。</p></blockquote><p>在<code>Texture::Bind()</code>函数的定义中，<code>glActiveTexture(GL_TEXTURE0 + slot)</code>用于激活纹理单元（纹理槽），一旦激活纹理单元，将会影响其上绑定的纹理对象。<code>+ slot</code>是因为<code>GL_TEXTURE1 = GLTEXTURE0 + 1</code>, …，可以此激活不同的纹理对象。</p><p>此后在Application.cpp中建立Texture对象，并在<code>texture.Bind()</code>后跟上<code>shader.SetUniform1i(&quot;u_Texture&quot;, 0);</code>，因为前者在我们的函数中默认绑定了slot 0.</p><p>我们还需要建立texture坐标，在positions数组中添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相应的更改VertexBufferLayout, Shader</p><p>修改后的Basic.shader:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">gl_Position</span> = position;</span><br><span class="line">v_TexCoord = texCoord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(u_Texture, v_TexCoord);<span class="comment">//使用 texture 函数从纹理 u_texture 中采样纹理颜色，并将结果存储在 textColor 中</span></span><br><span class="line">color = texColor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此后得到的结果仍有些怪异，因为未启用Blending，因此透明区域未被渲染。在Application.cpp中添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));<span class="comment">//定义如何正确blend alpha pixel</span></span><br></pre></td></tr></table></figure><p>当想要在原有颜色上重新绘制其他颜色，设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">1-\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的透明度就可以看出差异。</p><blockquote><p>©<code>glBlendFunc</code> 函数用于设置混合函数，它决定了如何混合源颜色（新绘制的颜色）和目标颜色（已存在的颜色）。</p><ul><li><code>GL_SRC_ALPHA</code> 表示源颜色使用 alpha 值作为权重。</li><li><code>GL_ONE_MINUS_SRC_ALPHA</code> 表示目标颜色使用 1 减去源颜色的 alpha 值作为权重。</li><li>这个混合函数通常用于标准的透明度混合，其中源颜色的 alpha 值用于控制新绘制的颜色在最终混合中的权重，而目标颜色的 alpha 值则用于控制已存在颜色在混合中的权重。</li></ul></blockquote><hr><h2 id="18-Blending">18 Blending</h2><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927001644674.png" alt="image-20230927001644674" style="zoom:50%;"><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927001823159.png" alt="image-20230927001823159" style="zoom:50%;"><p>上图中，<code>glBlendFunc()</code>用于定义src和dest的混合权重，<code>glBlendEquation()</code>用于定义如何计算混合值。</p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927002003981.png" alt="image-20230927002003981" style="zoom:50%;"><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927002056148.png" alt="image-20230927002056148" style="zoom:50%;"><hr><h2 id="19-Maths">19 Maths</h2><p>引入glm库，使用glm库创建正交投影矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>glm::mat4</code> 表示创建一个4x4的矩阵，这是通常用于进行图形变换的矩阵类型。</p><ul><li><code>glm::ortho</code> 是glm库中的一个函数，用于创建正交投影矩阵。它接受6个参数，分别是左、右、底、顶、近裁剪面和远裁剪面的坐标值。<ul><li><code>-2.0f</code> 和 <code>2.0f</code> 分别表示左和右裁剪面的x坐标范围，即从-2到2。</li><li><code>-1.5f</code> 和 <code>1.5f</code> 分别表示底和顶裁剪面的y坐标范围，即从-1.5到1.5。</li><li><code>-1.0f</code> 和 <code>1.0f</code> 分别表示近裁剪面和远裁剪面的z坐标范围，即从-1到1。</li></ul></li></ul></blockquote><p>在Basic.shader中vertex shader部分添加<code>uniform mat4 u_MVP;</code>(model view projection)，并在输出坐标乘上该投影。</p><p>在Application.cpp中添加<code>shader.SetUniformMat4f(&quot;u_MVP&quot;, proj);</code></p><p>在shader.h及cpp中完善该函数，需调用<code>glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &amp;matrix[0][0])</code>，其中GL_FALSE表示不需要转置该矩阵</p><hr><h2 id="20-Projection-Matrices">20 Projection Matrices</h2><p>从3D到2D，需要投影矩阵。</p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927094206912.png" alt="image-20230927094206912" style="zoom:50%;"><p>在之前的<code>glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</code>中，规定了x轴视图只有-2到2，超出该范围的点将不在屏幕上显示</p><p>该正交矩阵的作用在于将输入坐标投影至-1到1的区间上（屏幕上）</p><p>比如将position数组及正交矩阵改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">    <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">    <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">    <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>则图标会出现在屏幕左下角位置</p><p>注：<code>vp</code>以及<code>result</code>只是调试时测试投影矩阵功能的</p><hr><h2 id="21-Model-View-Projection">21  Model View Projection</h2><p>View matrix, or eye matrix, is the view of camera.</p><p>Model matrix is the way we simulate model. TRS.</p><blockquote><p>view matrix是相机position and orientation，model matrix是object transform.</p></blockquote><p>我们要做的是将这三种矩阵乘起来。</p><blockquote><p><a href="https://blog.csdn.net/grace_yi/article/details/108292085">模型（Model）、观察（View）和投影（Projection）详解_model projection-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/261097735">计算机图形学 5：齐次坐标与 MVP 矩阵变换 - 知乎 (zhihu.com)</a></p></blockquote><p>上节中建立了projection matrix，下面建立view matrix.</p><p>view matrix是相机，当我们把相机左移100时相当于将物体右移100</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>)</span></span>;</span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br></pre></td></tr></table></figure><p>接下来是model matrix，我们将之左移200并上移200</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br></pre></td></tr></table></figure><hr><h2 id="22-ImGui">22 ImGui</h2><p>通过一个已有的ui便捷地控制参数，地址：<a href="https://github.com/ocornut/imgui/releases?q=1.60&amp;expanded=true">1.60 · Releases · ocornut/imgui (github.com)</a></p><p>复制部分文件到工程目录下，其中main.cpp不能包含在工程中，仅做用例</p><p>通过对main.cpp的模仿，改编Application.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/glm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/gtc/matrix_transform.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_glfw_gl3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> positions[] = &#123;</span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">        VertexArray va;</span><br><span class="line">        <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        VertexBufferLayout layout;</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line">        </span><br><span class="line">        <span class="function">IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">        <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>)</span></span>;</span><br><span class="line">        shader.<span class="built_in">Bind</span>();</span><br><span class="line">        shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">        <span class="function">Texture <span class="title">texture</span><span class="params">(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>)</span></span>;</span><br><span class="line">        texture.<span class="built_in">Bind</span>();</span><br><span class="line">        shader.<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        va.<span class="built_in">Unbind</span>();</span><br><span class="line">        shader.<span class="built_in">Unbind</span>();</span><br><span class="line">        vb.<span class="built_in">Unbind</span>();</span><br><span class="line">        ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line">        Renderer renderer;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfwGL3_Init</span>(window, <span class="literal">true</span>);</span><br><span class="line">        ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> show_demo_window = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> show_another_window = <span class="literal">false</span>;</span><br><span class="line">        ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">        <span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">        <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Render here */</span></span><br><span class="line">            renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ImGui_ImplGlfwGL3_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">            shader.<span class="built_in">Bind</span>();</span><br><span class="line">            shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">                increment = <span class="number">-0.05f</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">                increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">            r += increment;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>);                           <span class="comment">// Display some text (you can use a format string too)</span></span><br><span class="line">                ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>);            <span class="comment">// Edit 1 float using a slider from 0.0f to 1.0f    </span></span><br><span class="line">                ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="type">float</span>*)&amp;clear_color); <span class="comment">// Edit 3 floats representing a color</span></span><br><span class="line"></span><br><span class="line">                ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);      <span class="comment">// Edit bools storing our windows open/close state</span></span><br><span class="line">                ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))                            <span class="comment">// Buttons return true when clicked (NB: most widgets return true when edited/activated)</span></span><br><span class="line">                    counter++;</span><br><span class="line">                ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Render</span>();</span><br><span class="line">            <span class="built_in">ImGui_ImplGlfwGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">            <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Poll for and process events */</span></span><br><span class="line">            <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_Shutdown</span>();</span><br><span class="line">    ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后将model matrix以及mvp移入while循环中，这样可以通过滑块更新每次打印时的model matrix.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation);<span class="comment">//每次循环都可以改变model</span></span><br><span class="line">    <span class="comment">//mat4(1.0f)是indentity matrix</span></span><br><span class="line">    glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation&quot;</span>, &amp;translation.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);<span class="comment">//关联滑块，0到960是之前设置的范围</span></span><br><span class="line">        ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="23-Rendering-Multiple-Objects">23 Rendering Multiple Objects</h2><p>将</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translationA);</span><br><span class="line">    glm::mat4 mvp = proj * view * model;</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个块多次复制即可渲染出多个物体。</p><p>然而这样的效率是低下的，因此之后要学习batch rendering.</p><hr><h2 id="24-Setting-up-a-Test-Framework">24 Setting up a Test Framework</h2><p>建立测试，方法是在src/test下建立Test.h，之后建立继承类（本节介绍了TestClearColor）</p><p>之后更改Application.cpp以进行测试。但这样很破坏主程序，因此之后将采用菜单的方式测试。</p><hr><h2 id="25-Creating-Tests">25 Creating Tests</h2><p>先在之前的Test.h中添加<code>TestMenu</code>类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line">~<span class="built_in">TestMenu</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltatime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Test*&amp; m_CurrentTest;</span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>为什么不在<code>Test</code>类中用纯虚函数？因为之后的派生类中可以直接不写<code>void OnUpdate(float deltatime) override;</code>以及其他两个；而纯虚函数则不可能这样</p></blockquote><blockquote><p><code>m_Tests</code> 是一个私有成员变量，它是一个 <code>std::vector</code>，这是C++标准库提供的一种动态数组容器。在这个上下文中，<code>std::vector</code> 是一个能够动态增长和缩小的数组，存储类型为 <code>std::pair</code> 的元素。</p><p><code>std::pair</code> 是C++标准库提供的一个模板类，它可以存储两个不同类型的值。在这里，<code>std::pair</code> 包含了一个 <code>std::function</code> 对象，该对象可以持有可调用的实体（函数指针、函数对象、Lambda表达式等），以及这个可调用实体返回的 <code>Test*</code> 类型的指针。</p><p>所以，<code>m_Tests</code> 是一个动态数组，每个元素是一个 <code>std::pair</code>，其中包含了一个可以返回 <code>Test*</code> 指针的可调用实体。这样的设计通常用于实现一种工厂模式，即根据不同的可调用实体创建不同类型的对象。在这个特定的代码片段中，<code>m_Tests</code> 的目的可能是用于创建不同类型的 <code>Test</code> 对象。</p></blockquote><p>之后还需要在<code>TestMenu</code>中添加模板函数<code>RegisterTest()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterTest</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Register test &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">m_Tests.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(name, []() &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Test*&amp; m_CurrentTest;</span><br><span class="line">std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Lambda 表达式中包含了一个无参数的函数，该函数返回一个新创建的测试类的指针（<code>new T()</code>）。</p><p>这是lambda表达式的基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line"> // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中的lambda表达式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">[]() &#123; return new T(); &#125;</span><br></pre></td></tr></table></figure><ul><li><code>[]</code> 是一个空的捕获列表，表示lambda表达式没有捕获任何外部变量。</li><li><code>()</code> 是参数列表，这里是空的，表示lambda函数不接受任何参数。</li><li><code>&#123; return new T(); &#125;</code> 是lambda函数的函数体。它包含一个单一的语句，即使用 <code>new</code> 操作符创建了一个类型为 <code>T</code> 的新对象，并将其指针返回。</li></ul><p>在这个上下文中，lambda表达式充当了一个无参数函数，每当它被调用时，它会动态地创建一个新的 <code>T</code> 类型的对象，并将对象的指针返回。在这种情况下，lambda表达式被用作一个工厂函数，用于创建不同类型的测试对象。</p><p>总结起来，lambda表达式允许你在这个代码中以一种简洁的方式定义了一个匿名的函数，该函数的行为在每次被调用时都是动态的，它用于创建不同类型的测试对象。</p></blockquote><p>此后修改Application.cpp以完成相应任务</p><hr><h2 id="26-Creating-a-Texture-Test">26 Creating a Texture Test</h2><p>构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">test::TestTexture2D::<span class="built_in">TestTexture2D</span>()</span><br><span class="line">: <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)), </span><br><span class="line">    <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))), </span><br><span class="line">    <span class="built_in">m_TranslationA</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>), <span class="built_in">m_TranslationB</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> positions[] = &#123;</span><br><span class="line">        <span class="number">-50.0f</span>, <span class="number">-50.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">         <span class="number">50.0f</span>, <span class="number">-50.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">         <span class="number">50.0f</span>,  <span class="number">50.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">        <span class="number">-50.0f</span>,  <span class="number">50.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">    m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line">    <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    VertexBufferLayout layout;</span><br><span class="line">    layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">    layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">    m_VAO-&gt;<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line">    m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>);</span><br><span class="line">    m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时按F5生成整个项目并运行，点击2D Texture会出错。在出错时将线程回到main</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007155213213.png" alt="image-20231007155213213"></p><p>根据下面的输出</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007155246373.png" alt="image-20231007155246373"></p><p>（此处不知为何跟视频不一样）发现问题发生在<code>TestTexture2D::OnRender()</code>的<code>renderer.Draw(*m_VAO, *m_IndexBuffer, *m_Shader);</code>处</p><p>最后发现是上述代码中<code>VertexBuffer vb(positions, 4 * 4 * sizeof(float));</code>有误，因为该<code>vb</code>在上述<code>TestTexture2D</code>的构造函数结束时被析构（也即，调用了<code>~VertexBuffer()</code>）</p><hr><h2 id="27-How-to-make-your-Uniforms-Faster">27 How to make your Uniforms Faster</h2><p>之前做过了，就是在Shader.cpp中添加了一个unordered_map</p><p>不过这里进一步将<code>GetUniformLocation()</code>改成const函数，并在unordered_map前添加<code>mutable</code>关键词以示可以修改</p><blockquote><p>mutable 用来解决常函数中不能修改对象的数据成员的问题。</p></blockquote><hr><h2 id="28-Batch-Rendering-An-Introduction">28 Batch Rendering - An Introduction</h2><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007171841698.png" alt="image-20231007171841698"></p><p>如上图所示，若按原本的方式渲染两个正方形，则需要调用两次draw call. 但若我们将两个vertex buffer以及index buffer合并，则可以在一次draw call完成两个正方形的绘制。与之而来的是，vertex buffer应为动态的，这样在每次绘制前都能传输数据（不是很懂？）</p><hr><h2 id="29-Batch-Rendering-Colors">29 Batch Rendering - Colors</h2><p>只需要在上节基础上加上颜色即可</p><hr><h2 id="30-Batch-Rendering-Textures">30 Batch Rendering - Textures</h2><p>加入另一张图片，用另一个纹理进行采样。构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">test::TestBatchRender::<span class="built_in">TestBatchRender</span>()</span><br><span class="line">     : <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">     <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">     <span class="built_in">m_TranslationA</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>), <span class="built_in">m_TranslationB</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">float</span> positions[] = &#123;</span><br><span class="line">         <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">         <span class="number">300.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">400.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">400.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">300.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">         <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">     <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">     m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line"></span><br><span class="line">     m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="number">8</span> * <span class="number">11</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">     VertexBufferLayout layout;</span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>);  <span class="comment">//postion</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>);  <span class="comment">//color</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);  <span class="comment">//texture coordinate</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>);  <span class="comment">//texture slot</span></span><br><span class="line">     m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line"></span><br><span class="line">     m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">     m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Batch.shader&quot;</span>);</span><br><span class="line">     m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">     m_Texture[<span class="number">0</span>] = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>);</span><br><span class="line">     m_Texture[<span class="number">1</span>] = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/HazelLogo.png&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         m_Texture[i]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> samplers[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">     m_Shader-&gt;<span class="built_in">SetUniform1iv</span>(<span class="string">&quot;u_Textures&quot;</span>, <span class="number">2</span>, samplers);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>OnRender()</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> test::TestBatchRender::<span class="built_in">OnRender</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    Renderer renderer;</span><br><span class="line">    &#123;</span><br><span class="line">        m_Texture[<span class="number">0</span>]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">        glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">        renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        m_Texture[<span class="number">1</span>]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">        glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">        renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是留意在构造函数中对两个texture调用<code>Bind()</code>，以及在调用Draw前也要分别Bind</p><blockquote><p>实话实说，我不知道这么写对不对，虽然结果是对的，但调用了两次Draw，与Batch Rendering理念不符</p><p>一种做法或许是设置两个不同的<code>u_MVP</code>？之后做</p></blockquote><blockquote><p>更新：采用另一种函数<code>glBindTextureUnit()</code>完成了想要的效果，但是此时只能由一个滑块来控制（因为两张图片会一起动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> test::TestBatchRender::<span class="built_in">OnRender</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTextureUnit</span>(<span class="number">0</span>, m_Texture[<span class="number">0</span>]-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"><span class="built_in">glBindTextureUnit</span>(<span class="number">1</span>, m_Texture[<span class="number">1</span>]-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>glBindTexture</code> 和 <code>glBindTextureUnit</code> 是OpenGL中的两个不同的函数，它们用于绑定纹理到纹理单元，但在用法和功能上有一些区别。</p><ol><li><p><strong>glBindTexture</strong>:</p><p><code>glBindTexture</code> 函数用于将一个纹理绑定到当前OpenGL上下文的特定纹理目标（例如<code>GL_TEXTURE_2D</code>或<code>GL_TEXTURE_CUBE_MAP</code>）。它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBindTexture</span><span class="params">(GLenum target, GLuint texture)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数将指定的纹理对象（由参数<code>texture</code>指定）绑定到目标<code>target</code>上。绑定后，所有对该目标的纹理操作都会影响到被绑定的纹理对象。这意味着，之后的纹理操作会影响到当前绑定的纹理对象。</p></li><li><p><strong>glBindTextureUnit</strong>:</p><p><code>glBindTextureUnit</code> 函数是OpenGL 4.5版本引入的。它允许将一个纹理直接绑定到一个纹理单元（texture unit），而不是特定的纹理目标。这样，一个纹理可以在多个不同的纹理目标之间共享，或者在同一个着色器中绑定到多个不同的纹理目标上。它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBindTextureUnit</span><span class="params">(GLuint unit, GLuint texture)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数将纹理对象（由参数<code>texture</code>指定）绑定到指定的纹理单元<code>unit</code>上。绑定后，该纹理单元会包含被绑定的纹理对象，而不是特定的纹理目标。这种方法更加灵活，允许在不同的上下文中共享纹理对象，也更适合现代OpenGL编程的需求。</p><p>不像之前的OpenGL版本中（如OpenGL 3.x），在OpenGL 4.5及以上版本中，你不再需要在绑定纹理时指定纹理的类型（例如GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP等）。取而代之的是，OpenGL会根据纹理对象的类型自动选择正确的目标。</p></li></ol><p>总的来说，<code>glBindTexture</code> 是OpenGL早期版本中使用的函数，它将纹理对象绑定到特定的纹理目标上，而 <code>glBindTextureUnit</code> 则是OpenGL 4.5引入的新函数，它将纹理对象绑定到纹理单元上，提供了更灵活的纹理绑定方式。</p></blockquote><blockquote><ol><li><strong>纹理目标（Texture Target）</strong>：纹理目标是指纹理被绑定到的图形渲染管线的阶段。在OpenGL和DirectX等图形API中，纹理可以绑定到不同的目标上，例如2D纹理、立方体贴图、3D纹理等。不同的纹理目标决定了纹理将如何被使用和渲染。</li><li><strong>纹理对象（Texture Object）</strong>：纹理对象是指在图形渲染中用来存储和管理纹理数据的对象。当程序需要使用纹理时，通常会创建一个纹理对象，并将纹理数据加载到该对象中。纹理对象包含了纹理的各种属性和数据。</li><li><strong>纹理单元（Texture Unit）</strong>：纹理单元是图形渲染管线中的一个部分，它负责处理纹理采样和纹理操作。在图形渲染中，可以同时使用多个纹理，这些纹理可以在不同的纹理单元上进行绑定。每个纹理单元可以有不同的纹理目标和纹理对象，允许程序在渲染过程中使用多个纹理。</li></ol><p>纹理目标（Texture Target）、纹理对象（Texture Object）和纹理单元（Texture Unit）之间的关系如下：</p><ol><li><strong>纹理目标和纹理对象的关系</strong>：<ul><li><strong>纹理目标</strong>指定了纹理被用于渲染管线的哪个阶段，例如2D纹理、立方体贴图等。一个纹理对象可以被绑定到一个特定的纹理目标上。同一个纹理对象可以在不同的渲染阶段被绑定到不同的纹理目标上，以满足渲染需求。</li></ul></li><li><strong>纹理对象和纹理单元的关系</strong>：<ul><li><strong>纹理对象</strong>是存储和管理纹理数据的数据结构。在图形编程中，您通常会创建一个纹理对象，将图像数据加载到这个对象中。一个纹理对象可以被绑定到一个或多个<strong>纹理单元</strong>上。</li><li><strong>纹理单元</strong>是图形渲染管线中的一个部分，负责处理纹理采样和纹理操作。每个纹理单元可以有一个纹理对象绑定到上面。当渲染时，着色器程序可以通过纹理单元来访问与之相关联的纹理对象，从而进行纹理采样等操作。</li></ul></li></ol><p>综上所述，纹理目标定义了纹理在渲染管线中的用途，纹理对象存储了纹理的数据和属性，而纹理单元则负责管理纹理对象的使用，允许多个纹理对象同时存在，并在渲染过程中被正确地绑定和采样。这三者共同协作，使得在图形渲染中能够有效地使用和处理纹理数据。</p></blockquote><blockquote><p><a href="https://blog.csdn.net/hankern/article/details/122799884#:~:text=glGenTex,%E5%92%8C%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB">openGL之API学习（一九九）纹理单元和纹理对象的关系-CSDN博客</a></p><p>glGenTextures产生的是纹理对象（简称纹理），纹理单元数量在GPU上确定的，不需要创建，glBindTexture将纹理对象绑定到当前纹理单元的的目标类型上（一个纹理单元可以有多个类型1D、2D（注：即纹理目标）等，一个纹理对象能够绑定到多个目标类型上），一个纹理对象可以绑定到多个纹理单元上，一个纹理单元上只能有一个同种纹理类型（如果有多个采样会无所适从）</p><p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAaGFua2Vybg==,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p></blockquote></blockquote><p>更新：翻了各种博客，愣是没看出<code>glBindTexture()</code>和<code>glBindTextureUnit()</code>有什么本质上的区别……最后发现是因为没在调<code>Texture::Bind()</code>时加参数……</p><p>今天看到收获较大的有关纹理的博客有（可以知道batch rendering-textures的具体代码）：<br><a href="https://blog.csdn.net/hankern/article/details/88084372">纹理单元、纹理对象、纹理类型、取样器对象_纹理单元和纹理-CSDN博客</a><br>[纹理 - LearnOpenGL-CN](<a href="https://learnopengl-cn.readthedocs.io/zh/latest/01">https://learnopengl-cn.readthedocs.io/zh/latest/01</a> Getting started/06 Textures/)<br><a href="https://blog.csdn.net/mumufan05/article/details/98970729">OpenGL学习笔记：多个纹理_shader 多个纹理坐标-CSDN博客</a></p><p>总结下就是，每个显卡有个最大的纹理单元数，每个纹理单元上可以有多个纹理目标用于绑定纹理对象，纹理对象可以绑定多个纹理目标。<br>使用纹理必须要：ActivateTexture-&gt;BindTexture-&gt;shader中uniform的关联（一个uniform对应一个纹理单元）<br>不过现在也是一个滑块控制两个图片，二者同时被移动，不过这也正常，毕竟是一起通过一个draw call绘制的，相对坐标不会变</p><hr><p>##31 Batch Rendering - Dynamic Geometry</p><p>原来的<code>position</code>数组是静态的，现在将之改为可变的</p><p>我们首先要修改<code>glBufferData</code>，将之用做分配内存。具体改法是为每个vertex建立struct用于存储各项属性，之后调用<code>glBufferData(GL_ARRAY_BUFFER, 1000 * sizeof(Vertex), nullptr, GL_DYNAMIC_DRAW)</code>. 这里nullptr表明只是用作分配内存，而GL_DYNAMIC_DRAW则表明会动态变化。</p><p>此后在<code>BindBuffer()</code>后需要用某种方式将数据发送到vertex buffer. 一种方式是调用<code>glMapBuffer()</code>，这里使用更低版本支持的<code>glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);</code></p><blockquote><p><a href="https://docs.gl/gl4/glMapBuffer">glMapBuffer - OpenGL 4 - docs.gl</a><br><a href="https://docs.gl/gl4/glBufferSubData">glBufferSubData - OpenGL 4 - docs.gl</a></p></blockquote><p>之后新建函数<code>CreateQuad()</code>，接受三个参数x, y以及textureID，传回两个图片各自所需的<code>std::array&lt;Vertex, 4&gt;</code>并将其<code>memcpy()</code>到<code>vertices</code>中。最后通过ImGui提供的滑块来控制x, y. 最终实现效果与[30 Batch Rendering - Textures](#30 Batch Rendering - Textures)效果类似，只是方式不同，上面是通过调整MVP矩阵实现移动，这里则是改变顶点坐标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> Position[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> Color[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> TextCoord[<span class="number">2</span>];</span><br><span class="line">    <span class="type">float</span> TextID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::array&lt;Vertex, 4&gt; <span class="title">CreateQuad</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">int</span> TextID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> size = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x + size, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; v0, v1, v2, v3 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样写会疯狂报错，因为数组不能像上面那样赋值，因此添加几个struct用于赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::array&lt;Vertex, 4&gt; <span class="title">CreateQuad</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> TextID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> size = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v1;</span><br><span class="line">    v1.Position = &#123; x + size, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v1.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v1.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v1.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v2;</span><br><span class="line">    v2.Position = &#123; x + size, y + size, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v3;</span><br><span class="line">    v3.Position = &#123; x, y + size, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.TextCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; v0, v1, v2, v3 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个看似没问题，实际上<code>v0.TextCoord</code>出问题了，导致结果如下：</p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231008235827097.png" alt="image-20231008235827097" style="zoom:67%;"><p>以我目前的水平不足以分析为什么会长成上面这样，不过改对了就行了。（？）</p><hr><p>完结撒花！前后用时挺久的，大概八月下旬开始做，断断续续到10/8，花了一个半月，不过收获还不错。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Selenium实现阿里云盘自动签到</title>
      <link href="/2023/05/03/%E9%80%9A%E8%BF%87Selenium%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/"/>
      <url>/2023/05/03/%E9%80%9A%E8%BF%87Selenium%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</url>
      
        <content type="html"><![CDATA[<p>记录第一次使用Selenium完成阿里云盘签到的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line">driver = webdriver.Chrome(options=option)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.aliyundrive.com/sign/in&quot;</span>)</span><br><span class="line">iframe=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line">iframe=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line">login=driver.find_elements(By.CSS_SELECTOR, <span class="string">&quot;div.login-blocks.block0&gt;.sms-login-link&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">login.click()</span><br><span class="line"></span><br><span class="line">user=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;input#fm-login-id&quot;</span>)</span><br><span class="line">passwd=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;input#fm-login-password&quot;</span>)</span><br><span class="line">user.send_keys(<span class="string">&quot;&quot;</span>)<span class="comment"># 账号</span></span><br><span class="line">passwd.send_keys(<span class="string">&quot;&quot;</span>) <span class="comment"># 密码</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># driver.switch_to.frame(driver.find_element(By.CSS_SELECTOR, &quot;iframe&quot;))</span></span><br><span class="line"><span class="comment"># element=driver.find_element(By.CSS_SELECTOR,&quot;div#nc_1__scale_text.scale_text.slidetounlock&quot;)</span></span><br><span class="line"><span class="comment"># dragger=driver.find_element(By.CSS_SELECTOR, &quot;span#nc_1_n1z.nc_iconfont.btn_slide&quot;)</span></span><br><span class="line"><span class="comment"># action=ActionChains(driver)</span></span><br><span class="line"><span class="comment"># print(element.size[&#x27;width&#x27;])</span></span><br><span class="line"><span class="comment"># action.click_and_hold(dragger).perform() </span></span><br><span class="line"><span class="comment"># action.drag_and_drop_by_offset(dragger,element.size[&#x27;width&#x27;],0)</span></span><br><span class="line"><span class="comment"># action.perform()</span></span><br><span class="line"></span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;button.fm-button.fm-submit.password-login[tabindex=&#x27;3&#x27;]&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">windows=driver.window_handles</span><br><span class="line">driver.switch_to.window(windows[-<span class="number">1</span>])</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;div.sign-btn---rZSA&quot;</span>).click()</span><br><span class="line"><span class="comment"># driver.switch_to.default_content()</span></span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe[src=&#x27;https://pages.aliyundrive.com/mobile-page/web/dailycheckpc.html&#x27;]&quot;</span>))</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;img[src=&#x27;//gw.alicdn.com/imgextra/i4/O1CN01aVlk0J1KIALJhQfCV_!!6000000001140-2-tps-72-72.png&#x27;]&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">driver.switch_to.default_content()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;span[data-icon-type=&#x27;PDSMoreCircle&#x27;]&gt;svg&quot;</span>).click() <span class="comment"># 设置</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(driver.find_elements(By.CSS_SELECTOR, <span class="string">&quot;div.outer-menu--ihDUR&quot;</span>))[-<span class="number">1</span>].click()  <span class="comment"># 退出登录</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;button.ant-btn.ant-btn-primary.ant-btn-dangerous&quot;</span>).click() <span class="comment"># 确认</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>首先在阿里云盘登录界面切换至账号密码登录，此时面临的第一个问题是滑块</p><h2 id="滑块">滑块</h2><p>在输入账号密码后会弹出滑块，让用户从左推到右。这算是比较简单的一种反爬虫手段了，然而我半天都没弄好</p><p>首先是尝试动作链<code>ActionChains</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action = ActionChains(driver)</span><br><span class="line">action.drag_and_drop(dragger, item1).perform()  # 1.移动dragger到目标1</span><br><span class="line">sleep(2)</span><br><span class="line">action.click_and_hold(dragger).release(item2).perform()  # 2.效果与上句相同，也能起到移动效果</span><br><span class="line">sleep(2)</span><br><span class="line">action.click_and_hold(dragger).move_to_element(item3).release().perform()  # 3.效果与上两句相同，也能起到移动的效果</span><br><span class="line">sleep(2)</span><br><span class="line"># action.drag_and_drop_by_offset(dragger, 400, 150).perform()  # 4.移动到指定坐标</span><br><span class="line">action.click_and_hold(dragger).move_by_offset(400, 150).release().perform()  # 5.与上一句相同，移动到指定坐标 </span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/lxbmaomao/p/10389786.html">Selenium之动作链（ActionChains） - liangxb - 博客园 (cnblogs.com)</a></p></blockquote><p>大致就是上面几种方法，还有些改进方法，如调整拖拽速度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver=webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.qichacha.com/user_login&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;normalLogin&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">huakuai=driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;nc_1_n1z&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_track</span>(<span class="params">distance</span>):      <span class="comment"># distance为传入的总距离</span></span><br><span class="line">    <span class="comment"># 移动轨迹</span></span><br><span class="line">    track=[]</span><br><span class="line">    <span class="comment"># 当前位移</span></span><br><span class="line">    current=<span class="number">0</span></span><br><span class="line">    <span class="comment"># 减速阈值</span></span><br><span class="line">    mid=distance*<span class="number">4</span>/<span class="number">5</span></span><br><span class="line">    <span class="comment"># 计算间隔</span></span><br><span class="line">    t=<span class="number">0.2</span></span><br><span class="line">    <span class="comment"># 初速度</span></span><br><span class="line">    v=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> current&lt;distance:</span><br><span class="line">        <span class="keyword">if</span> current&lt;mid:</span><br><span class="line">            <span class="comment"># 加速度为2</span></span><br><span class="line">            a=<span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 加速度为-2</span></span><br><span class="line">            a=-<span class="number">3</span></span><br><span class="line">        v0=v</span><br><span class="line">        <span class="comment"># 当前速度</span></span><br><span class="line">        v=v0+a*t</span><br><span class="line">        <span class="comment"># 移动距离</span></span><br><span class="line">        move=v0*t+<span class="number">1</span>/<span class="number">2</span>*a*t*t</span><br><span class="line">        <span class="comment"># 当前位移</span></span><br><span class="line">        current+=move</span><br><span class="line">        <span class="comment"># 加入轨迹</span></span><br><span class="line">        track.append(<span class="built_in">round</span>(move))</span><br><span class="line">    <span class="keyword">return</span> track</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_to_gap</span>(<span class="params">slider,tracks</span>):     <span class="comment"># slider是要移动的滑块,tracks是要传入的移动轨迹</span></span><br><span class="line">    ActionChains(driver).click_and_hold(slider).perform()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tracks:</span><br><span class="line">        ActionChains(driver).move_by_offset(xoffset=x,yoffset=<span class="number">0</span>).perform()</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    ActionChains(driver).release().perform()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    move_to_gap(huakuai,get_track(<span class="number">340</span>))</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.jianshu.com/p/f1fef22a14f4">Python+Selenium 拖动滑块 （一） - 简书 (jianshu.com)</a></p></blockquote><p>另外的参考文章：<a href="https://blog.csdn.net/weixin_49981930/article/details/123577466">selenium之滑块操作_selenium拖动滑块_王大傻0928的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u012067766/article/details/79793264">使用selenium模拟登录解决滑块验证问题_锅炉房刘大爷的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_36259105/article/details/108326268">python- selenium 淘宝爬虫之滑块验证（滑动速度放慢版）_move_by_offset速度控制_小泽泽泽ya的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_34067049/article/details/93474296">selenium 滑动解锁（drag_and_drop_by_offset）_weixin_34067049的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_27346427/article/details/127867436">Selenium鼠标方法drag_and_drop_by_offset、move_by_offset无响应_我乱来的a的博客-CSDN博客</a></p><p>然而实际上都没用，因为阿里云盘设置了一些反爬虫手段</p><hr><h2 id="隐去特征">隐去特征</h2><p>那么应该如何解决呢？</p><p>参考<a href="https://zhuanlan.zhihu.com/p/389042694">selenium 反爬虫之跳过滑块验证 - 知乎 (zhihu.com)</a>， 在原有代码前加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line">driver = webdriver.Chrome(options=option)</span><br></pre></td></tr></table></figure><p>以及参考<a href="https://blog.csdn.net/MICHAELKING1/article/details/108322795">修改Chromedriver特征字符串_chromedriver 特征_MichaelYZ111的博客-CSDN博客</a>，在Kali中用hexedit修改chromedriver.exe</p><p>将$cdc_asdjflasutopfhvcZLmcfl_改为任意字符</p><blockquote><p>关于Options()，如登录时关闭密码保存提示框：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prefs = &#123;&#125;  <span class="comment"># 设置这两个参数就可以避免密码提示框的弹出</span></span><br><span class="line">prefs[<span class="string">&#x27;credentials_enable_service&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">prefs[<span class="string">&#x27;profile.password_manager_enabled&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>, prefs) </span><br></pre></td></tr></table></figure><p>其他用途参考：</p><p><a href="https://blog.csdn.net/zzrs_xssh/article/details/106006939">selenium之options模块_selenium options__xiao_gu的博客-CSDN博客</a></p></blockquote><p>就惊奇地发现不再需要滑块验证了！</p><hr><h2 id="Notes">Notes</h2><p>之后便是水到渠成，有几个值得注意的点：</p><ol><li><p>切换window, frame之后要加<code>time.sleep(1)</code>，否则其后的<code>find_element</code>会找不到</p></li><li><p>有时候<code>CSS_SELECTOR</code>写的不好（不准确是一方面，有时候有些啥啥啥-id还会变，就不能用这个作为定位器）会导致定位到其他元素上，因此务必确保每一步都写对。</p><blockquote><p>更方便的办法是F12右键copy selector，但仍有动态变化的可能</p><p>详见<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8Dselector">下文</a></p></blockquote></li><li><p>做了好多次后发现突然又要滑块验证了，猜测是ip被察觉到异常访问了，于是在命令行中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/release</span><br><span class="line">ipconfig/renew</span><br></pre></td></tr></table></figure><p>获得新地址即可</p></li></ol><hr><h2 id="等待">等待</h2><p>将<code>time.sleep(1)</code>替换为隐式等待<code>driver.implicity_wait(30)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">option.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line">prefs = &#123;&#125;  <span class="comment"># 设置这两个参数就可以避免密码提示框的弹出</span></span><br><span class="line">prefs[<span class="string">&#x27;credentials_enable_service&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">prefs[<span class="string">&#x27;profile.password_manager_enabled&#x27;</span>] = <span class="literal">False</span> </span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;prefs&#x27;</span>, prefs) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=option)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.aliyundrive.com/sign/in&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>)  <span class="comment"># 隐式等待</span></span><br><span class="line"></span><br><span class="line">iframe=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line">iframe=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line">login=driver.find_elements(By.CSS_SELECTOR, <span class="string">&quot;div.login-blocks.block0&gt;.sms-login-link&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">login.click()</span><br><span class="line"></span><br><span class="line">user=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;input#fm-login-id&quot;</span>)</span><br><span class="line">passwd=driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;input#fm-login-password&quot;</span>)</span><br><span class="line">user.send_keys(<span class="string">&quot;18381605149&quot;</span>)</span><br><span class="line">passwd.send_keys(<span class="string">&quot;xuharry2022&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;button.fm-button.fm-submit.password-login[tabindex=&#x27;3&#x27;]&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">windows=driver.window_handles</span><br><span class="line">driver.switch_to.window(windows[-<span class="number">1</span>])</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;#layout &gt; div.sider--3QQ75 &gt; div &gt; div &gt; div &gt; div.simplebar-wrapper &gt; div.simplebar-mask &gt; div &gt; div &gt; div &gt; div &gt; div.sider-top--2wTJr &gt; ul &gt; div &gt; div &gt; div.sign-btn---rZSA&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;iframe[src=&#x27;https://pages.aliyundrive.com/mobile-page/web/dailycheckpc.html&#x27;]&quot;</span>))</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;#root &gt; div &gt; div.rax-view-v2.DailyCheckPc--main--1cbm8da &gt; div.rax-view-v2.DailyCheckPc--header--2CXJvuw &gt; div &gt; img&quot;</span>).click() <span class="comment"># 关闭</span></span><br><span class="line"></span><br><span class="line">driver.switch_to.default_content()</span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;#layout &gt; div.sider--3QQ75 &gt; div &gt; div &gt; div &gt; div.simplebar-wrapper &gt; div.simplebar-mask &gt; div &gt; div &gt; div &gt; div &gt; div.sider-bottom--2ltRW &gt; div.bottom-wrapper--19rog &gt; div.ant-dropdown-trigger.more-wrapper--2dMhX &gt; span &gt; svg&quot;</span>).click() <span class="comment"># 设置</span></span><br><span class="line"></span><br><span class="line">(driver.find_elements(By.CSS_SELECTOR, <span class="string">&quot;body &gt; div:nth-child(12) &gt; div &gt; div &gt; ul &gt; li:nth-child(13) &gt; div &gt; div&quot;</span>))[-<span class="number">1</span>].click()  <span class="comment"># 退出登录</span></span><br><span class="line"></span><br><span class="line">driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;body &gt; div:nth-child(14) &gt; div &gt; div.ant-modal-wrap &gt; div &gt; div.ant-modal-content &gt; div &gt; div &gt; div.ant-modal-confirm-btns &gt; button.ant-btn.ant-btn-primary.ant-btn-dangerous&quot;</span>).click() <span class="comment"># 确认</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>关于显式和隐式的区别，</p><p>隐式等待的好处是不用像固定等待方法一样死等时间N秒，可以在一定程度上提升测试用例的执行效率。不过这种方法也存在一定的弊端，那就是程序会一直等待整个页面加载完成，也就是说浏览器窗口标签栏中不再出现转动的小圆圈，才会继续执行下一步。</p><p>显示等待会每个一段时间（该时间一般都很短，默认为0.5秒，也可以自定义），执行自定义的程序判断条件，如果判断条件成立，就执行下一步，否则继续等待，直到超过设定的最长等待时间，然后抛出TimeOutEcpection的异常信息。</p><blockquote><p><a href="https://blog.csdn.net/biggbang/article/details/121511531">selenium之WebDriverWait类（等待机制）_虚坏叔叔的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/harryzzz/article/details/78812309">implicitly_wait()隐式等待和explicit_wait()显示等待_implicitly_wait用法_油菜花啊的博客-CSDN博客</a></p></blockquote><hr><h2 id="正则表达式匹配selector">正则表达式匹配selector</h2><p>在“退出登录”那步，复制selector得到：<code>body &gt; div:nth-child(12) &gt; div &gt; div &gt; ul &gt; li:nth-child(13) &gt; div &gt; div</code></p><blockquote><p>CSS中的 <code>:nth-child()</code> 是一个伪类选择器，用于匹配其父元素的第 n 个子元素。而 <code>div:nth-child()</code> 则是指父元素的所有子元素中为 <code>div</code> 标签的第 n 个元素。</p><p>在给定的代码中，<code>div:nth-child(12)</code> 表示父元素中所有 <code>div</code> 标签的第 12 个元素，而 <code>li:nth-child(13)</code> 表示父元素中所有 <code>li</code> 标签的第 13 个元素。最终，<code>div:nth-child(12) &gt; div &gt; div &gt; ul &gt; li:nth-child(13) &gt; div &gt; div</code> 表示一个元素，它是具有如上所述子元素层次结构的 <code>div</code> 元素的子元素，即父元素的第 12 个 <code>div</code> 标签，其子元素是一个 <code>div</code> 标签，该标签的子元素是一个 <code>ul</code> 标签，<code>ul</code> 标签的子元素中第 13 个 <code>li</code> 标签，该 <code>li</code> 标签的子元素是一个 <code>div</code> 标签，而该 <code>div</code> 标签又具有一个子元素为 <code>div</code> 标签。</p></blockquote><p>但这时可能会变成body &gt; div:nth-child(13) &gt; div &gt; div &gt; ul &gt; li:nth-child(12) &gt; div &gt; div</p><p>这种情况甚至不好用正则表达式匹配</p><blockquote><p>重新测试数次，都没再遇到上述情况，遂作罢</p></blockquote><p>那么就不再对本次代码做正则匹配了。</p><hr><p>如果要做，比如…&gt;div.arch_main_开头的类：</p><p>首先定位到父元素，用<code>findall(r'arch_main_(.*)',element.get_attribute('innerHTML')</code>获得其中以arch_main_开头的字符串</p><blockquote><p>对get_attribute的测试：<code>print(driver.find_element(By.CSS_SELECTOR, &quot;div.sider-bottom--2ltRW &gt; div.bottom-wrapper--19rog&quot;.get_attribute(&quot;innerHTML&quot;))</code>可获得设置所在的div内容</p></blockquote><p>之后可以遍历字符串，去匹配类</p><blockquote><p>相关参考：</p><p><a href="./%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></p><p><a href="https://www.cnblogs.com/heiheixiaocai/p/13061356.html">结合Selenium和正则表达式提高爬虫效率 - TVHead - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/gaimechen/article/details/81947879">selenium get_attribute的几种用法_gaimechen的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u010574906/article/details/83067591">selenium利用正则表达式定位元素_selenium 正则表达式_杨二狗2333的博客-CSDN博客</a></p></blockquote><hr><h2 id="cookie登录">cookie登录</h2><p>参考<a href="https://www.cnblogs.com/CYHISTW/p/11685846.html">selenium cookie 登录 - 风，又奈何 - 博客园 (cnblogs.com)</a>，先手动登录并保存cookie至本地，之后即可自动登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动登录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#填写webdriver的保存目录</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">url=<span class="string">&#x27;https://www.csdn.net&#x27;</span></span><br><span class="line"><span class="comment">#记得写完整的url 包括http和https</span></span><br><span class="line">driver.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment">#程序打开网页后20秒内手动登陆账户</span></span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cookies.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> cookief:</span><br><span class="line">    <span class="comment">#将cookies保存为json格式</span></span><br><span class="line">    cookief.write(json.dumps(driver.get_cookies()))</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动登录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#填写webdriver的保存目录</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">url=<span class="string">&#x27;https://www.csdn.net&#x27;</span></span><br><span class="line"><span class="comment">#记得写完整的url 包括http和https</span></span><br><span class="line">driver.get(url)</span><br><span class="line"><span class="comment">#首先清除由于浏览器打开已有的cookies</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.delete_all_cookies()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cookies.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> cookief:</span><br><span class="line">    <span class="comment">#使用json读取cookies 注意读取的是文件 所以用load而不是loads</span></span><br><span class="line">    cookieslist = json.load(cookief)</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> cookieslist:</span><br><span class="line">        driver.add_cookie(cookie)</span><br><span class="line"></span><br><span class="line">driver.refresh()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">30</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>问题是cookie可能会失效，对此作者给出两种办法：</p><p>将expiry类型变为int / 删除该字段</p><p>另一篇文章用的方法类似，只是改为yaml: <a href="https://www.cnblogs.com/BlueSkyyj/p/8615879.html">Python Selenium Cookie 绕过验证码实现登录 - Blue·Sky - 博客园 (cnblogs.com)</a></p><p>这个也类似，获取sessionid和token，但没有实现token的更新：<a href="https://www.cnblogs.com/adolfmc/p/12639203.html">Python3+Selenium获取session和token供Requests使用教程 - adolfmc - 博客园 (cnblogs.com)</a></p><p>类似文章：<a href="https://blog.csdn.net/sinat_34209942/article/details/81235925">python+selenium 通过添加cookies或token解决网页上验证码登录问题_selenium token_aiee的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/VirusScanLog/article/details/122120799">【Selenium 小知识】获取 token 和 cookies_selenium获取token_Warolitbos的博客-CSDN博客</a></p><p>略微不同的一篇博客，用了fiddler抓包获取token，之后直接带着token前往登录后的界面：</p><p><a href="https://www.cnblogs.com/yhms/p/10877198.html">11、python+selenium绕过验证码登录 - YLG001 - 博客园 (cnblogs.com)</a></p><hr><p>翻了好久仍没找到想要的，即如何像CSDN上<a href="https://blog.csdn.net/weixin_47811387/article/details/129311423">阿里云盘三月自动签到Python脚本，可本地、青龙、云函数自动执行_残荷亭的博客-CSDN博客</a>做的，通过refresh_token获得新的access_token以及refresh_token，上面那些大都是通过手动方式获得token/cookie/sessionid，总结下就是cookie用<code>get_cookie()</code>，token/sessionid用<code>driver.ececute_script('return sessionStorage.getItem(&quot;token&quot;)')</code>这种。</p><hr><h2 id="待研究">待研究</h2><ul><li>借助refresh_token获取access_token</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
