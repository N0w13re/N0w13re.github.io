<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OpenGL笔记 | Harry's Blog</title><meta name="author" content="Harry"><meta name="copyright" content="Harry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="油管博主The Cherno的OpenGL教程">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL笔记">
<meta property="og:url" content="https://n0w13re.github.io/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Harry&#39;s Blog">
<meta property="og:description" content="油管博主The Cherno的OpenGL教程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://n0w13re.github.io/img/road-8395119_1280.jpg">
<meta property="article:published_time" content="2023-10-13T08:19:30.000Z">
<meta property="article:modified_time" content="2023-11-21T03:07:14.754Z">
<meta property="article:author" content="Harry">
<meta property="article:tag" content="OpenGL">
<meta property="article:tag" content="图形学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://n0w13re.github.io/img/road-8395119_1280.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://n0w13re.github.io/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenGL笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-21 11:07:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/2b.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/road-8395119_1280.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Harry's Blog"><span class="site-name">Harry's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OpenGL笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T08:19:30.000Z" title="发表于 2023-10-13 16:19:30">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-21T03:07:14.754Z" title="更新于 2023-11-21 11:07:14">2023-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenGL笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>OpenGL教程</h1>
<p>视频链接：<a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2">OpenGL - YouTube</a></p>
<p>B站搬运链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MJ411u7Bc/?vd_source=4b566ae72f027eb58b211581c0cfc339">最好的OpenGL教程之一_哔哩哔哩_bilibili</a></p>
<p>Github仓库链接：<a target="_blank" rel="noopener" href="https://github.com/N0w13re/OpenGL">N0w13re/OpenGL (github.com)</a></p>
<blockquote>
<p>前三节没做笔记，可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42741249/article/details/125732070">openGl新手入门学习笔记（一）什么是openGl，使用glfw库和环境搭建_opengl glfw_埃卡洛斯的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42741249/article/details/125737731">openGl新手入门学习笔记（二）下载glew，配置glew的环境与glew的初始化_埃卡洛斯的博客-CSDN博客</a></p>
</blockquote>
<h2 id="04-Vertex-Buffers-and-Drawing-a-Triangle">04 Vertex Buffers and Drawing a Triangle</h2>
<blockquote>
<p>在调整visual studio自动补全，遇到个问题是输入<code>unsigned</code>，当我按下<code>n</code>后<code>u</code>会被自动补全为<code>uint16</code>，搞半天才发现是成员列表提交字符那里我输入了enter…于是每次遇到这些字符都会触发补全</p>
<p>正确做法是删掉这些字符，回车键是默认的</p>
</blockquote>
<p>opengl是状态机，为生成的所有东西分配了唯一标识，是实际对象（顶点缓冲、顶点数组、纹理、着色器）的id，需要用这个对象时就调用这个id</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;    </span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br></pre></td></tr></table></figure>
<p>上述<code>buffer</code>就是id</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer)</span><br></pre></td></tr></table></figure>
<p>该代码说明刚生成的buffer的用途</p>
<p>接下来既可以提供数据，也可以之后再提供。以下演示直接提供三角形数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[<span class="number">6</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里教了在<a target="_blank" rel="noopener" href="https://docs.gl/">docs.gl</a>中查阅函数参数，比如<code>glBufferData()</code>，通过该文档得知第二个参数以字节为单位，也得知参数<code>usage</code>中的static以及dynamic的区别</p>
</blockquote>
<p>接下来是绘制。由于还没学到着色器（shader），没有index buffer，因此借助<code>glDrawArrays()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLE, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230826114915802.png" alt="image-20230826114915802"></p>
<p>但这是不完整的，因此是黑屏输出</p>
<p>另一种绘制的函数是<code>glDrawElements()</code>，一般跟index buffer一起用，之后讲。</p>
<p>上述代码能绘制的原因在于之前有<code>glBindBuffer()</code>绑定了，若绑错了就会绘制到其他“图层”上去</p>
<hr>
<h2 id="05-Vertex-Attributes-and-Layouts">05 Vertex Attributes and Layouts</h2>
<p>首先要区分vertex和position是不同的，vertex是点，坐标只是它的一个attribute</p>
<p>指定attribute时需调用函数<a target="_blank" rel="noopener" href="https://docs.gl/gl4/glVertexAttribPointer">glVertexAttribPointer()</a>，告诉OpenGL如何解释和处理顶点数据。下面介绍其参数：</p>
<ul>
<li>index: 所需修改的attribute是第几个，比如可以规定坐标是第0个，颜色是第1个，法线（normal）是第2个……</li>
<li>size: 每个属性的组件数量，比如之前的每个坐标就有2个分量</li>
<li>type: 略</li>
<li>normalized: 将0-255规约至0-1</li>
<li>stride: buffer中一个vertex所有属性的字节大小和</li>
<li>position: 略，注意此position已经在顶点中了</li>
</ul>
<p>例如，上述第一个vertex的第一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要第二个属性可以将<code>position</code>参数改为<code>(const int *)4</code></p>
</blockquote>
<p>此外还需在其前加上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>通过这两行代码，就告诉了opengl我们的buffer的layout是什么样的</p>
<hr>
<h2 id="06-How-Shaders-Work">06 How Shaders Work</h2>
<p>着色器用于处理传入的数据，最流行的两种shader：vertex shader, fracture shader, 后者又称为pixel shader</p>
<p>rendering pipeline is how do we go from having data to actually having results on the screen</p>
<p>当我们发出draw call时，vertex shader, fracture shader先后被调用</p>
<p>vertex shader告诉opengl想在哪里绘制这三个点，这样opengl才能在屏幕上找到对应坐标。每个vertex调用一次。</p>
<p>fracture shader作用是告诉opengl三角形中每个像素点的颜色，用于之后rasterization stage中的rasterize（光栅化，也就是实际绘制该像素点）。每个像素点调用一次。</p>
<hr>
<h2 id="07-Writing-a-Shader">07 Writing a Shader</h2>
<p>首先是创建shader的函数接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fractureShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来完成CompileShader():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();	<span class="comment">//亦可写作&amp;source[0]，总之指向数据区首字节地址</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);	<span class="comment">//Replaces the source code in a shader object</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> ERROR handling</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后继续完成CreateShader()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vs);	<span class="comment">//由于已经link到program上了，中间产物(intermediates)可以删掉</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来完善CompileShader()中的TODO:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);	<span class="comment">//https://docs.gl/gl4/glCompileShader中有提及用该函数验证</span></span><br><span class="line">    <span class="keyword">if</span> (!result)	<span class="comment">//可以是result == GL_FALSE, 不过GL_FALSE等于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="type">char</span> *message = (<span class="type">char</span> *)<span class="built_in">alloca</span>(length * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to Compile &quot;</span> &lt;&lt;</span><br><span class="line">            (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot;shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>alloc()</code>函数是在栈上分配空间，详情参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/lingling_1/article/details/47445273">malloc、calloc、realloc、new以及alloca函数区别_malloc new alloca_勇敢无畏的活着的博客-CSDN博客</a></p>
<p>此后在<code>main()</code>函数中调用<code>CreateShader()</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::string vertexShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span>	<span class="comment">//version 330:没用更新的版本是因为暂时不需要那么复杂</span></span><br><span class="line">    						<span class="comment">//core表示不使用deprecated的函数</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) in vec4 position;\n&quot;</span>	<span class="comment">//0是index of attribute</span></span><br><span class="line">		<span class="comment">//至于为什么是vec4而不是vec2?因为之后gl_Position是vec4，就算这里用了vec2之后也得用vec4(position.xy,0,0)去扩展</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;gl_Position = position;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string fragmentShader =</span><br><span class="line">    <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout(location = 0) out vec4 color;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;color = vec4(1.0, 0.0, 0.0, 1.0);\n&quot;</span>	<span class="comment">//rgba</span></span><br><span class="line">    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suyimin2010/article/details/99700711">layout(location=0) in vec4 vPosition_layout(location = 0) in vec4 position;_Luckie stone的博客-CSDN博客</a></p>
<ol>
<li>
<p>vPosition指变量名称，它所保存的是顶点的位置信息</p>
</li>
<li>
<p>vec4是GLSL中的一种数据类型，在这里表示GLSL的四维浮点数向量，默认值为(0,0,0,1)，表示(x,y,z,w)。当有字段缺失时，会填充对应的默认值。</p>
</li>
<li>
<p>in字段的话，表示设置这个变量，即vPosition为着色器阶段的输入变量，指定了数据进入着色器的流向，在这里代表数据从外部流入。</p>
</li>
<li>
<p>layout(location=0)，这一字段非常重要，它将vPosition的位置属性location设置为0，为它提供了元数据。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/89325452">openGL之API学习（四十七）layout作用详解_glsl layout-CSDN博客</a></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="keyword">attribute</span> <span class="keyword">index</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br></pre></td></tr></table></figure>
<p>可以指定顶点着色器输入变量使用的顶点属性索引值，一般在glVertexAttribPointer中指定属性索引值。如果同时使用了glBindAttribLocation，那么这个layout优先。</p>
</blockquote>
<blockquote>
<p>©<code>position</code> 是这个顶点着色器中定义的一个输入变量，通常用于表示顶点的位置信息。下面是对 <code>position</code> 变量的详细解释：</p>
<ol>
<li>
<p><strong>变量类型</strong>：<code>position</code> 被定义为 <code>vec4</code> 类型的变量。<code>vec4</code> 是GLSL中的一种矢量类型，表示一个包含四个分量的向量。通常，顶点的位置可以由一个三维向量 (x, y, z) 表示，但在这里使用了一个四维向量，通常情况下第四个分量（通常是w）被用于进行坐标变换和投影。</p>
</li>
<li>
<p><strong>输入变量</strong>：<code>position</code> 是一个输入变量，因为它以 <code>in</code> 关键字定义。这意味着 <code>position</code> 的值将由渲染管道的前阶段（通常是应用程序代码）提供给顶点着色器。这通常是从顶点缓冲对象（VBO）中读取的顶点数据。</p>
</li>
<li>
<p><strong>位置属性</strong>：通常情况下，<code>position</code> 变量用于表示顶点在模型坐标系中的位置。这是指顶点相对于模型的局部坐标系的位置，还没有经过任何变换。在顶点着色器中，您可以对这些位置进行变换，以将它们转换到世界坐标系、相机坐标系和裁剪空间，从而最终在屏幕上进行渲染。</p>
</li>
<li>
<p><strong>用途</strong>：<code>position</code> 变量通常用于将顶点的位置信息传递给图形渲染管道的后续阶段，特别是裁剪阶段和视口变换阶段。在这些阶段，它将经过一系列的变换和处理，最终确定每个顶点在屏幕上的位置。</p>
</li>
</ol>
<p>总之，<code>position</code> 是顶点着色器中用于表示顶点位置的输入变量，它是一个四维向量，通常表示顶点在模型坐标系中的位置，而在顶点着色器中，您可以对这些位置进行各种变换，以便进行后续的渲染操作。</p>
</blockquote>
<blockquote>
<p>该段GLSL与之前<code>glVertexAtttibPointer()</code>的联系：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37459951/article/details/96433508">OpenGL glVertexAttribPointer（）函数解析_soft_logic的博客-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入<code>0</code>。</p>
</blockquote>
<blockquote>
<p>总结下，<code>layout</code>那句是GLSL的声明，声明position这个变量，并使其获得属性位置0处的数据；而<code>glVertexAttribPointer</code>是定义从GL_ARRAY_BUFFER传数据进入shader的方式，比如给属性位置0处传入代表坐标的positions数组</p>
</blockquote>
<p>编译生成得到红色三角形。如果去掉color后的分号，拿去编译，会提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to Compile fragmentshader!</span><br><span class="line">ERROR: 0:4: &#x27;void&#x27; : syntax error syntax error</span><br></pre></td></tr></table></figure>
<p>表示我们的错误处理代码正确</p>
<p>此外，最后应加上清除代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDeleteProgram</span>(shader);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="08-How-Do-I-Deal-with-Shaders">08 How Do I Deal with Shaders</h2>
<p>该节讲述了如何将上述shader代码独立成文件</p>
<p>新建<code>res\shaders\Basic.shader</code>，写入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#shader vertex</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec4 position;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	gl_Position = position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#shader fragment</span><br><span class="line">#version 330 core</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec4 color;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	color = vec4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一开始没弄对，新建的是筛选器，筛选器只是表面上的分类，实际并未新建文件夹。需要点击“显示所有文件”，之后才能新建文件夹</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Kit-L/p/13888534.html">VisualStudio如何在解决方案里添加真实的文件夹而不是虚的解决方案文件夹 - Kit_L - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>此后在主文件中添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ShaderProgramSource</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string VertexSource;</span><br><span class="line">    std::string FragmentSource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> ShaderProgramSource <span class="title">ParseShader</span><span class="params">(std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">ShaderType</span></span><br><span class="line">    &#123;</span><br><span class="line">        NONE = <span class="number">-1</span>, VERTEX = <span class="number">0</span>, FRAGMENT = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    std::stringstream ss[<span class="number">2</span>];</span><br><span class="line">    ShaderType type = ShaderType::NONE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(stream, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;#shader&quot;</span>) != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;vertex&quot;</span>) != <span class="number">-1</span>)</span><br><span class="line">                type = ShaderType::VERTEX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">find</span>(<span class="string">&quot;fragment&quot;</span>) != <span class="number">-1</span>)</span><br><span class="line">                type = ShaderType::FRAGMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ss[(<span class="type">int</span>)type] &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; ss[<span class="number">0</span>].<span class="built_in">str</span>(), ss[<span class="number">1</span>].<span class="built_in">str</span>() &#125;;	<span class="comment">//str()将stringstream转为string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>stringstream</code>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/liitdar/article/details/82598039">C++编程语言中stringstream类介绍_liitdar的博客-CSDN博客</a></p>
<p>此后在<code>main()</code>中调用<code>ParseShader()</code>并测试（需删去后面跟shader有关的函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source = <span class="string">&quot;/res/shaders/Basic.shader&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; source.VertexSource &lt;&lt; std::endl;</span><br><span class="line">Std::cout &lt;&lt; source.FragmentSource &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错：</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230902215629770.png" alt="image-20230902215629770"></p>
<p>将<code>ParseShader()</code>中参数前加上<code>const</code>即可</p>
</blockquote>
<p>最后版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ShaderProgramSource source = <span class="built_in">ParseShader</span>(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(source.VertexSource, source.FragmentSource);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="09-Index-Buffers">09 Index Buffers</h2>
<p>如何画个正方形？将其看做两个三角形，因此需要修改如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">-0.5f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="number">6</span> * <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), positions, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	 <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>缺点是<code>position</code>数组中有重复点，因此需要index buffer来复用</p>
<p>删去<code>position</code>数组中重复点，添加index buffer如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,   <span class="comment">//0</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,   <span class="comment">//1</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,   <span class="comment">//2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>    <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;	<span class="comment">//必须unsigned</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仿照之前的buffer，另外创建绑定index buffer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ibo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ibo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo);	<span class="comment">//第一个参数不同</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>将while循环内的<code>glDrawArrays()</code>改为<code>glDrawElements()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);	<span class="comment">//6是indices中元素个数；最后的参数是pointer to index buffer，由于之前已经将index buffer绑定在GL_ELEMENT_ARRAY_BUFFER，因此不需要放指针</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="10-Dealing-with-Errors">10 Dealing with Errors</h2>
<p>两种函数常用语处理错误，<code>glGetError()</code>与<code>glDebugMessageCallback()</code>，后者功能更强但仅支持4.3版本及之后。本节内容主要关注前者。根据<a target="_blank" rel="noopener" href="https://docs.gl/gl4/glGetError">glGetError - OpenGL 4 - docs.gl</a>:</p>
<blockquote>
<p>To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to <code>GL_NO_ERROR</code> when <code>glGetError</code> is called. If more than one flag has recorded an error, <code>glGetError</code> returns and clears an arbitrary error flag value. Thus, <code>glGetError</code> should always be called in a loop, until it returns <code>GL_NO_ERROR</code>, if all error flags are to be reset.</p>
</blockquote>
<p>必须在循环中调用。</p>
<p>在开头添加函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLClearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">glGetError</span>() != GL_NO_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLCheckError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后将原来<code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);</code>中的<code>GL_UNSIGNED_INT</code>改为<code>GL_INT</code>，同时在前后添加上述两个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLClearError</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_INT, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">GLCheckError</span>();</span><br></pre></td></tr></table></figure>
<p>运行可以得到1280的错误信息</p>
<p>将其通过打断点的方式转为十六进制0x500，在glew.h中搜索<code>0x0500</code>，可得<code>#define GL_INVALID_ENUM 0x0500</code></p>
<p>然而这样的方式是在已知错误语句的情况下完成的，显然不符需要。因此采用断言</p>
<p>首先将<code>GLCheckError()</code>改为返回bool类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在开头添加宏<code>#define ASSERT(x) if (!(x)) __debugbreak();</code></p>
<p>将<code>GLCheckError()</code>改为<code>ASSERT(GLLogCall());</code>，运行后循环一次就会停下</p>
<blockquote>
<p><code>__debugbreak()</code>仅在MSVC环境下支持，clang等不支持</p>
</blockquote>
<p>继续添加宏定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\		<span class="comment">//注意\表示该行未结束，后面不能有空格</span></span></span><br><span class="line">    x;\</span><br><span class="line">    <span class="built_in">ASSERT</span>(<span class="built_in">GLLogCall</span>())</span><br></pre></td></tr></table></figure>
<p>即可将之前的三句指令简化为<code>GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));</code></p>
<p>多文件下想要快速定位出问题的地方，可以在<code>GLLogCall()</code>添加参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">GLLogCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *function, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GLenum error = <span class="built_in">glGetError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[OpenGL ERROR] (&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; function &lt;&lt;</span><br><span class="line">            <span class="string">&quot; &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将宏改为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLCall(x) GLClearError();\</span></span><br><span class="line"><span class="meta">    x;\</span></span><br><span class="line"><span class="meta">    ASSERT(GLLogCall(#x, __FILE__, __LINE__))	<span class="comment">//#将后面的宏参数进行字符串</span></span></span><br></pre></td></tr></table></figure>
<p>再次运行代码，就能定位出具体哪里出的bug</p>
<p>此后要做的就是，每个调用OpenGL函数的地方都加上<code>GLCall()</code></p>
<blockquote>
<p>有提到上面这种宏会有flaw（缺陷），当x是在单行if语句时，在两侧加上<code>GLCall()</code>，则仅有第一行代码会在if语句中。解决方案是采用scope或者do while循环</p>
<blockquote>
<p>并不是很明白为什么那样会出问题，搜了下发现c++17后多了个init-statement，但不知道有何联系（？）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangsenuestc/article/details/79841515">C++17新特性(2) – if/switch初始化(Init statement for if/switch)_c++17 新特性 if 定义_yangsenUCAS的博客-CSDN博客</a></p>
</blockquote>
<p>但用scope的方法（就是加花括号）又会有别的问题，比如<code>unsigned int id = glCreateShader(type);</code>，若我们在其两侧加了花括号，将导致之后的id均无法使用（因为id在scope内）</p>
</blockquote>
<hr>
<h2 id="11-Uniforms">11 Uniforms</h2>
<p>uniform是从cpu获取数据到shader的一种方式，可以被当作变量使用。uniform每次绘制都需要设置。</p>
<p>将fragment shader部分改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uniform vec4 u_Color;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	color = u_Color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在main函数<code>glUseProgram()</code>后添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>));</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（C)这段代码看起来是使用OpenGL进行着色器参数设置的代码片段。让我们逐行进行分析：</p>
<ol>
<li>
<p><code>GLCall(int location = glGetUniformLocation(shader, &quot;u_Color&quot;));</code></p>
<p>这一行代码调用了一个名为 <code>GLCall</code> 的函数，它的作用是用来检查OpenGL函数调用是否出错，并返回函数调用的结果。这里调用了 <code>glGetUniformLocation</code> 函数，该函数用于获取着色器程序中 uniform 变量的位置（location）。它的参数 <code>shader</code> 是着色器程序的句柄，而 <code>&quot;u_Color&quot;</code> 是要获取位置的 uniform 变量的名称。如果找不到该名称的 uniform 变量，<code>glGetUniformLocation</code> 将返回 -1。</p>
</li>
<li>
<p><code>ASSERT(location != -1);</code></p>
<p>这一行代码使用了一个断言，用于检查 <code>glGetUniformLocation</code> 返回的 <code>location</code> 是否不等于 -1。如果 <code>location</code> 等于 -1，这意味着无法找到名称为 “u_Color” 的 uniform 变量，可能是由于名称拼写错误或者该变量在着色器程序中不存在。断言用于在这种情况下终止程序的执行，以便及早发现问题。</p>
</li>
<li>
<p><code>GLCall(glUniform4f(location, 0.2f, 0.3f, 0.8f, 1.0f));</code></p>
<p>这一行代码使用 <code>glUniform4f</code> 函数来设置名为 “u_Color” 的 uniform 变量的值。它接受 <code>location</code>（在前一行获取的）作为第一个参数，然后将一个四维向量 (0.2f, 0.3f, 0.8f, 1.0f) 分配给该 uniform 变量。这将改变该 uniform 变量在着色器程序中的值，影响着色器的渲染结果。</p>
</li>
</ol>
<p>总的来说，这段代码的作用是设置着色器程序中的一个 uniform 变量 “u_Color” 的值为 (0.2f, 0.3f, 0.8f, 1.0f)，并且在找不到该 uniform 变量或者其他OpenGL调用错误时进行错误检查和处理。注意，可能存在与 <code>GLCall</code> 和 <code>ASSERT</code> 相关的宏定义或函数实现，以执行错误检查和处理的具体逻辑，但这里的代码片段并未包含这些定义或实现。</p>
</blockquote>
<p>再做出如下改动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="type">int</span> location = <span class="built_in">glGetUniformLocation</span>(shader, <span class="string">&quot;u_Color&quot;</span>));</span><br><span class="line"><span class="built_in">ASSERT</span>(location != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果是在蓝和粉之间跳跃。因为红通道在0和1之间跳跃。</p>
<p>在<code>glfwMakeContext();</code>后加上<code>glfwSwapInterval(1);</code>，用于开启图形渲染的垂直同步</p>
<blockquote>
<p><code>glfwSwapInterval</code> 是 GLFW 库中的函数，用于控制垂直同步（Vertical Synchronization，简称V-Sync）的行为。V-Sync 是一种图形渲染技术，用于防止图像撕裂（tearing），同时将帧速率与显示器的刷新率同步。</p>
<p>以下是有关 <code>glfwSwapInterval</code> 函数的详细信息：</p>
<ol>
<li>
<p><strong>函数签名</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glfwSwapInterval</span><span class="params">(<span class="type">int</span> interval)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>功能</strong>：</p>
<ul>
<li><code>glfwSwapInterval</code> 用于控制图形渲染的垂直同步。</li>
<li><code>interval</code> 参数指定了要设置的垂直同步模式。通常情况下，它可以是以下之一：
<ul>
<li>0：禁用垂直同步，允许无限制地渲染帧，可能会导致撕裂。</li>
<li>1：启用垂直同步，将渲染帧与显示器的刷新率同步，防止撕裂。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>垂直同步对于控制帧速率以及提高图形渲染的平滑度非常有用，特别是在游戏和图形应用程序中。</p>
</blockquote>
<blockquote>
<p>Q: 如何更改使得长方形沿对角，分别显示两种不同的颜色？</p>
<p>C: 要使长方形沿对角线分别显示两种不同的颜色，你可以在顶点数据中添加颜色信息，并在着色器中根据顶点的位置来插值颜色。以下是如何修改你的代码来实现这个效果的步骤：</p>
<ol>
<li>
<p>修改顶点数据：</p>
<p>首先，你需要修改顶点数据以便每个顶点都有一个颜色属性。为了使矩形沿对角线分别显示两种不同的颜色，你可以为每个顶点分配不同的颜色值。这里，我们假设你要使用红色和绿色两种颜色，可以修改你的 <code>positions</code> 数组和顶点属性的设置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置               // 颜色</span></span><br><span class="line">   <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角，红色</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下角，绿色</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// 右上角，蓝色</span></span><br><span class="line">   <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>  <span class="comment">// 左上角，黄色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们在每个顶点后面添加了颜色属性，每个顶点有五个值：x坐标、y坐标、红色分量、绿色分量和蓝色分量。</p>
</li>
<li>
<p>修改顶点属性指针：</p>
<p>在你的代码中，你需要修改顶点属性指针来正确处理颜色数据。在 <code>GLCall(glVertexAttribPointer(...))</code> 调用中，修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>))));</span><br></pre></td></tr></table></figure>
<p>这里，我们启用了第一个属性（位置属性）和第二个属性（颜色属性），并通过 <code>glVertexAttribPointer</code> 指定了它们的属性大小和偏移量。位置属性有两个浮点数（x和y坐标），所以属性大小是2，颜色属性有三个浮点数（红色、绿色和蓝色分量），所以属性大小是3。颜色属性的偏移量为 <code>2 * sizeof(float)</code>，因为位置属性占据了前两个浮点数的空间。</p>
</li>
<li>
<p>修改着色器：</p>
<p>在着色器中，你需要接收颜色属性并在片段着色器中插值它们。以下是修改着色器的示例：</p>
<p>顶点着色器（<code>Basic.shader</code> 中的内容）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">                  </span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> a_Position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> a_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> v_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(a_Position, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    v_Color = a_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器（<code>Basic.shader</code> 中的内容）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">                  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> v_Color;</span><br><span class="line">                  </span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line">                  </span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(v_Color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们在顶点着色器中接收颜色属性并将它传递到片段着色器中，然后在片段着色器中使用颜色属性设置片段颜色。</p>
</li>
</ol>
<p>完成这些步骤后，你的长方形应该沿对角线分别显示红色和绿色，因为你在每个顶点上指定了不同的颜色值。希望这能帮助你实现你的目标！</p>
</blockquote>
<hr>
<h2 id="12-Vertex-Arrays">12 Vertex Arrays</h2>
<p><code>glVertexAttribPointer()</code>并不是跟缓冲区绑定在一起的（并非存储在buffer中），而是跟vertex array object绑定在一起的。</p>
<p>为做测试，先在while循环前解绑所有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>将while循环改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可得到相同结果。问题是，每次都需要<code>glEnableVertexAttribArray(0)</code>以及<code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0)</code>吗？答案是是的，因为可能下次画的时候layout就不同了。而vertex array object恰好包含这个信息，如果我们为每个要绘制的图形创建一个顶点数组对象，则对于每次绘制，我们仅需要绑定顶点数组对象。因为VAO包含vertex buffer与实际的vertex specification或者说vertex layout间的绑定；换句话说<code>glVertexAttribPointer()</code>会绑定vertex buffer和array buffer(GL_ARRAY_BUFFER)。OpenGL compatability profile会默认为我们创建VAO，但core profile不会，因此需要我们手动创建。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object">Vertex_Array_Object</a></p>
<p>The compatibility OpenGL profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all. So if VAO 0 is bound in the core profile, you should not call any function that modifies VAO state. This includes binding the <code>GL_ELEMENT_ARRAY_BUFFER</code> with <a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/GLAPI/glBindBuffer">glBindBuffer</a>.</p>
<blockquote>
<p>©在OpenGL中，VAO（Vertex Array Object）是一种用于管理顶点数据和渲染状态的对象。OpenGL有两种不同的配置文件（profile）：兼容性（compatibility）配置文件和核心（core）配置文件。这两个配置文件的行为在某些方面有所不同。</p>
<ol>
<li>
<p><strong>兼容性OpenGL配置文件</strong>：在兼容性配置文件中，VAO对象0被视为默认对象。这意味着如果没有显式绑定VAO，OpenGL将使用默认的VAO对象0。在此配置文件中，可以调用一些函数来修改VAO对象0的状态，包括绑定<code>GL_ELEMENT_ARRAY_BUFFER</code>。</p>
</li>
<li>
<p><strong>核心OpenGL配置文件</strong>：在核心配置文件中，VAO对象0不被视为对象。这意味着VAO对象0在核心配置文件中不可用。如果尝试在核心配置文件中绑定VAO对象0，应该避免调用任何会修改VAO状态的函数，包括绑定<code>GL_ELEMENT_ARRAY_BUFFER</code>。</p>
</li>
</ol>
<p>简而言之，兼容性OpenGL配置文件允许VAO对象0的使用，并允许在其上进行状态更改操作，而核心OpenGL配置文件禁用了VAO对象0，因此在核心配置文件中不应该对其进行任何操作。这是OpenGL版本之间的一个重要差异，需要根据所使用的配置文件来谨慎管理VAO对象的状态。</p>
</blockquote>
</blockquote>
<p>在<code>glfwCreateWindow()</code>前添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<p>此时会将版本号调整为3.3，并用core profile，运行，就会在<code>glEnableVertexAttribArray()</code>报错，1282(=0x00000502)，在glew.h中搜索0x0502可知这是<code>GL_INVALID_OPERATION</code>，再从<a target="_blank" rel="noopener" href="https://docs.gl/gl4/glEnableVertexAttribArray">glEnableVertexAttribArray - OpenGL 4 - docs.gl</a>得知，这是因为没有VAO被绑定。（确切的说，根据<a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object">Vertex_Array_Object</a>，core profile根本就没有VAO 0)</p>
<p>在<code>glBindBuffer()</code>前添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao));</span><br></pre></td></tr></table></figure>
<p>再度运行，成功。</p>
<p>更进一步，将while循环改成：（对比起见，在解绑的三条指令前添加<code>GLCall(glBindVertexArray(0))</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUseProgram</span>(shader));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glUniform4f</span>(location, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindVertexArray</span>(vao));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ibo));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在while循环中删去了一些指令，只剩下绑定vao以及index buffer，但效果与之前相同。</p>
<p>解释：<code>glBindVertexArray(vao)</code>以及<code>glBindBuffer(GL_ARRAY_BUFFER, buffer)</code>并没有将二者连接起来，但<code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0)</code> makes index 0 of this vertex array be bound to GL_ARRAY_BUFFER.</p>
<blockquote>
<p>不知道啥意思，总之就是这条指令连接了VAO与VBO(vertex buffer object, 也即buffer变量对应的对象)</p>
</blockquote>
<p>如果将<code>glVertexAttribPointer()</code>的第一个参数改为1, 那么vao的index 1会指向其他buffer.</p>
<blockquote>
<p>实际上也可以将index buffer绑定在vao上</p>
</blockquote>
<p>大型项目的两种做法：一种是就只要一个vao，每次绑定不同的buffer；另一种是每个geometry都设置一个vao. 各有优劣，依实际选择。</p>
<hr>
<h2 id="13-Abstracting-into-Classes">13  Abstracting into Classes</h2>
<p>将错误处理部分单独提出来作为Renderer.cpp以及Renderer.h</p>
<p>将生成GL_ARRAY_BUFFER的部分提出来作为VertexBuffer.cpp以及.h</p>
<p>将生成GL_ELEMENT_ARRAY_BUFFER的部分作为IndexBuffer.cpp以及.h</p>
<blockquote>
<p>在生成index buffer的时候，将参数从vertex buffer的<code>const void* </code>改为<code>const unsigned int* </code>，<code>size</code>改为<code>count</code>，因为<code>size</code>一般是作为字节数，而这里已经声明了是<code>unsigned int</code>，则应该传入其个数<code>count</code></p>
</blockquote>
<p>修改Application.cpp后运行，仍能弹出矩形，但关闭窗口后，命令台并不会退出。点击暂停调试，查看堆栈：</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230923114142560.png" alt="image-20230923114142560"></p>
<p>这是因为程序退出时要运行析构函数，但在<code>return 0</code>前就已经有<code>glfwTerminate()</code>，摧毁了OpenGL context. 此时由于失去context，<code>GLGetError()</code>就会一直报错</p>
<p>我们可以通过new与delete手动调用解构，不过这里用scope的方式，加花括号。</p>
<hr>
<h2 id="14-Buffer-Layout-Abstraction">14 Buffer Layout Abstraction</h2>
<p>VAO的作用是将vertex buffer以及其layout整合在一起</p>
<p>本节将vertex buffer, index buffer, vertex buffer layout以及最主要的vertex array分别抽象出来为单独的文件</p>
<hr>
<h2 id="15-Shader-Abstraction">15 Shader Abstraction</h2>
<p>将Shader抽象出Shader.cpp及.h</p>
<hr>
<h2 id="16-Writing-a-Basic-Renderering">16 Writing a Basic Renderering</h2>
<p>在Renderer.h中添加Renderer类并加入成员函数<code>Draw()</code></p>
<p>不过在编译时出现如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	C3861	“ASSERT”: 找不到标识符	OpenGL	D:\Projects\OpenGL\OpenGL\src\VertexBufferLayout.h	20	</span><br></pre></td></tr></table></figure>
<p>但打开VertexBufferLayout.h会看到我们包含了Renderer.h文件，而Renderer.h中有ASSERT的宏定义</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230926142756700.png" alt="image-20230926142756700"></p>
<p>究其原因，此时我们在LayoutBuffer.h中<code>#include &quot;Renderer.h&quot;</code>，又在Renderer.h中<code>#include &quot;VertexArray.h&quot;</code>（包含这个是因为<code>Draw</code>函数需要使用），而VertexArray.h中有<code>#include &quot;VertexBufferLayout.h&quot;</code>，如此导致循环包含，这种情况会导致编译器陷入无限循环，因为它无法确定要包含的头文件的顺序。</p>
<p>此处采用的方法是将VertexArray.h添加<code>class VertexBufferLayout;</code>，并在VertexBuffer.cpp中加入<code>#include &quot;VertexBufferLayout.h&quot;</code></p>
<blockquote>
<p>©在VertexArray.h这段代码中，<code>class VertexBufferLayout;</code> 是一个前置声明（forward declaration）。前置声明是一种告诉编译器某个类或类型将在稍后的代码中定义的方式。它告诉编译器有关类 <code>VertexBufferLayout</code> 的基本信息，但不提供关于类的详细定义。这种声明通常用于解决循环依赖或仅需要知道类型的名称而不需要知道其内部结构的情况。</p>
<p>在这里，<code>VertexArray</code> 类中使用了 <code>VertexBufferLayout</code> 类的对象作为参数，但它并没有包含 <code>VertexBufferLayout.h</code> 的头文件。相反，它只是在类定义之前声明了 <code>VertexBufferLayout</code> 类。这允许编译器在编译此文件时知道 <code>VertexBufferLayout</code> 类的名称和基本信息，而不需要了解其详细定义。然后，在其他地方的代码中，你需要包含 <code>VertexBufferLayout.h</code> 头文件，以获得关于 <code>VertexBufferLayout</code> 类的实际定义。</p>
<p>这种前置声明有助于减少编译时间，特别是在大型代码库中，因为它可以减少不必要的头文件包含。但请确保在使用 <code>VertexBufferLayout</code> 类的任何实际功能之前，你必须包含相关的头文件以获取完整的定义。</p>
</blockquote>
<blockquote>
<p>弹幕说这种方式对于大型项目是危险的，正确处理方式是将宏定义单独写在一个头文件中</p>
</blockquote>
<p>完成后，此时每次渲染前仍需绑定shader以及指定uniform，这很麻烦，因此我们需要学习material. material就是renderer+shaders.</p>
<hr>
<h2 id="17-Textures">17 Textures</h2>
<p>新建Texture.h，输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_RendererID;</span><br><span class="line">	std::string m_FilePath;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* m_LocalBuffer;</span><br><span class="line">	<span class="type">int</span> m_Width, m_Height, m_BPP;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line">	~<span class="built_in">Texture</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slot = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Width; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Height; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>Bind()</code>需要加参数slot是因为可同时绑定多个texture，在windows上一般是32个，而手机上一般就只有8个（取决于GPU）</p>
<p>在<code>Texture</code>类的构造函数中添加<code>stbi_set_flip_vertically_on_load(1);</code>，因为OpenGL希望texture从左下角开始，左下角是(0,0). 而PNG是从上到下的，所以应当flip. 此后的<code>m_LoadBuffer = stbi_load(path.c_str(), &amp;m_Width, &amp;m_Height, &amp;m_BPP);</code>函数创建了加载texture的buffer.</p>
<p>在构造函数中创建Texture，并规定参数：</p>
<pre><code>GLCall(glGenTextures(1, &amp;m_RendererID));
GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));

GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
</code></pre>
<blockquote>
<p>©这里的代码执行了一系列OpenGL函数调用，用于设置纹理对象的参数，具体如下：</p>
<ol>
<li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</code>：设置2D纹理的缩小过滤器（minification filter）为线性过滤（GL_LINEAR）。这意味着当纹理被缩小时，OpenGL会使用线性插值来计算像素颜色。</li>
<li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</code>：设置2D纹理的放大过滤器（magnification filter）为线性过滤（GL_LINEAR）。这意味着当纹理被放大时，OpenGL会使用线性插值来计算像素颜色。</li>
<li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)</code>：设置2D纹理的水平包裹模式（wrap mode）为GL_CLAMP，这意味着当纹理坐标超出[0,1]的范围时，OpenGL会使用边缘的纹理像素颜色。</li>
<li><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)</code>：设置2D纹理的垂直包裹模式（wrap mode）为GL_CLAMP，与上一行类似，这意味着当纹理坐标超出[0,1]的范围时，OpenGL会使用边缘的纹理像素颜色。</li>
</ol>
</blockquote>
<p>接下来将buffer中数据传给texture:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个参数Internal_format是数据在内存中的数据格式，倒数第二个参数format则是传给OpenGL的数据格式</p>
<ul>
<li><code>GL_TEXTURE_2D</code>：指定了目标纹理类型，这里是2D纹理。</li>
<li><code>0</code>：指定了纹理的层级（level）。通常，0表示基本的纹理级别。</li>
<li><code>GL_RGBA8</code>：指定了纹理的内部格式（internal format）。在这里，它表示纹理内部存储的像素数据使用RGBA通道，每个通道占8位（一个字节）。</li>
<li><code>m_Width</code>：纹理的宽度（以像素为单位）。</li>
<li><code>m_Height</code>：纹理的高度（以像素为单位）。</li>
<li><code>0</code>：指定了边框的宽度。通常情况下，这是0。</li>
<li><code>GL_RGBA</code>：指定了源图像数据的格式，这里是RGBA格式。</li>
<li><code>GL_UNSIGNED_BYTE</code>：指定了源图像数据的数据类型，这里是无符号字节数据类型。</li>
<li><code>m_LocalBuffer</code>：包含纹理像素数据的指针，这是你要加载到纹理中的图像数据。</li>
</ul>
<p>这行代码的目的是将 <code>m_LocalBuffer</code> 中的图像数据加载到2D纹理对象中，并指定了有关纹理的各种参数，包括纹理的大小、格式等。这样，在渲染时，你可以将这个纹理绑定到一个纹理单元并使用它来渲染物体。</p>
</blockquote>
<p>在<code>Texture::Bind()</code>函数的定义中，<code>glActiveTexture(GL_TEXTURE0 + slot)</code>用于激活纹理单元（纹理槽），一旦激活纹理单元，将会影响其上绑定的纹理对象。<code>+ slot</code>是因为<code>GL_TEXTURE1 = GLTEXTURE0 + 1</code>, …，可以此激活不同的纹理对象。</p>
<p>此后在Application.cpp中建立Texture对象，并在<code>texture.Bind()</code>后跟上<code>shader.SetUniform1i(&quot;u_Texture&quot;, 0);</code>，因为前者在我们的函数中默认绑定了slot 0.</p>
<p>我们还需要建立texture坐标，在positions数组中添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相应的更改VertexBufferLayout, Shader</p>
<p>修改后的Basic.shader:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#shader vertex</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">gl_Position</span> = position;</span><br><span class="line">	v_TexCoord = texCoord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#shader fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(u_Texture, v_TexCoord);	<span class="comment">//使用 texture 函数从纹理 u_texture 中采样纹理颜色，并将结果存储在 textColor 中</span></span><br><span class="line">	color = texColor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此后得到的结果仍有些怪异，因为未启用Blending，因此透明区域未被渲染。在Application.cpp中添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));	<span class="comment">//定义如何正确blend alpha pixel</span></span><br></pre></td></tr></table></figure>
<p>当想要在原有颜色上重新绘制其他颜色，设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">1-\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的透明度就可以看出差异。</p>
<blockquote>
<p>©<code>glBlendFunc</code> 函数用于设置混合函数，它决定了如何混合源颜色（新绘制的颜色）和目标颜色（已存在的颜色）。</p>
<ul>
<li><code>GL_SRC_ALPHA</code> 表示源颜色使用 alpha 值作为权重。</li>
<li><code>GL_ONE_MINUS_SRC_ALPHA</code> 表示目标颜色使用 1 减去源颜色的 alpha 值作为权重。</li>
<li>这个混合函数通常用于标准的透明度混合，其中源颜色的 alpha 值用于控制新绘制的颜色在最终混合中的权重，而目标颜色的 alpha 值则用于控制已存在颜色在混合中的权重。</li>
</ul>
</blockquote>
<hr>
<h2 id="18-Blending">18 Blending</h2>
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927001644674.png" alt="image-20230927001644674" style="zoom:50%;">
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927001823159.png" alt="image-20230927001823159" style="zoom:50%;">
<p>上图中，<code>glBlendFunc()</code>用于定义src和dest的混合权重，<code>glBlendEquation()</code>用于定义如何计算混合值。</p>
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927002003981.png" alt="image-20230927002003981" style="zoom:50%;">
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927002056148.png" alt="image-20230927002056148" style="zoom:50%;">
<hr>
<h2 id="19-Maths">19 Maths</h2>
<p>引入glm库，使用glm库创建正交投影矩阵</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1.5f</span>, <span class="number">1.5f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>glm::mat4</code> 表示创建一个4x4的矩阵，这是通常用于进行图形变换的矩阵类型。</p>
<ul>
<li><code>glm::ortho</code> 是glm库中的一个函数，用于创建正交投影矩阵。它接受6个参数，分别是左、右、底、顶、近裁剪面和远裁剪面的坐标值。
<ul>
<li><code>-2.0f</code> 和 <code>2.0f</code> 分别表示左和右裁剪面的x坐标范围，即从-2到2。</li>
<li><code>-1.5f</code> 和 <code>1.5f</code> 分别表示底和顶裁剪面的y坐标范围，即从-1.5到1.5。</li>
<li><code>-1.0f</code> 和 <code>1.0f</code> 分别表示近裁剪面和远裁剪面的z坐标范围，即从-1到1。</li>
</ul>
</li>
</ul>
</blockquote>
<p>在Basic.shader中vertex shader部分添加<code>uniform mat4 u_MVP;</code>(model view projection)，并在输出坐标乘上该投影。</p>
<p>在Application.cpp中添加<code>shader.SetUniformMat4f(&quot;u_MVP&quot;, proj);</code></p>
<p>在shader.h及cpp中完善该函数，需调用<code>glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &amp;matrix[0][0])</code>，其中GL_FALSE表示不需要转置该矩阵</p>
<hr>
<h2 id="20-Projection-Matrices">20 Projection Matrices</h2>
<p>从3D到2D，需要投影矩阵。</p>
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20230927094206912.png" alt="image-20230927094206912" style="zoom:50%;">
<p>在之前的<code>glm::mat4 proj = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);</code>中，规定了x轴视图只有-2到2，超出该范围的点将不在屏幕上显示</p>
<p>该正交矩阵的作用在于将输入坐标投影至-1到1的区间上（屏幕上）</p>
<p>比如将position数组及正交矩阵改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123;</span><br><span class="line">    <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">    <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">    <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">    <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<p>则图标会出现在屏幕左下角位置</p>
<p>注：<code>vp</code>以及<code>result</code>只是调试时测试投影矩阵功能的</p>
<hr>
<h2 id="21-Model-View-Projection">21  Model View Projection</h2>
<p>View matrix, or eye matrix, is the view of camera.</p>
<p>Model matrix is the way we simulate model. TRS.</p>
<blockquote>
<p>view matrix是相机position and orientation，model matrix是object transform.</p>
</blockquote>
<p>我们要做的是将这三种矩阵乘起来。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/grace_yi/article/details/108292085">模型（Model）、观察（View）和投影（Projection）详解_model projection-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/261097735">计算机图形学 5：齐次坐标与 MVP 矩阵变换 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>上节中建立了projection matrix，下面建立view matrix.</p>
<p>view matrix是相机，当我们把相机左移100时相当于将物体右移100</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view;</span><br><span class="line"></span><br><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>)</span></span>;</span><br><span class="line">shader.<span class="built_in">Bind</span>();</span><br><span class="line">shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br></pre></td></tr></table></figure>
<p>接下来是model matrix，我们将之左移200并上移200</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">glm::mat4 mvp = proj * view * model;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-ImGui">22 ImGui</h2>
<p>通过一个已有的ui便捷地控制参数，地址：<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui/releases?q=1.60&amp;expanded=true">1.60 · Releases · ocornut/imgui (github.com)</a></p>
<p>复制部分文件到工程目录下，其中main.cpp不能包含在工程中，仅做用例</p>
<p>通过对main.cpp的模仿，改编Application.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexBufferLayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IndexBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;VertexArray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/glm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glm/gtc/matrix_transform.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui/imgui_impl_glfw_gl3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> positions[] = &#123;</span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">            <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">            <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">        <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">        VertexArray va;</span><br><span class="line">        <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        VertexBufferLayout layout;</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">        va.<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line">        </span><br><span class="line">        <span class="function">IndexBuffer <span class="title">ib</span><span class="params">(indices, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        glm::mat4 proj = glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 view = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">        <span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>)</span></span>;</span><br><span class="line">        shader.<span class="built_in">Bind</span>();</span><br><span class="line">        shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">        <span class="function">Texture <span class="title">texture</span><span class="params">(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>)</span></span>;</span><br><span class="line">        texture.<span class="built_in">Bind</span>();</span><br><span class="line">        shader.<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        va.<span class="built_in">Unbind</span>();</span><br><span class="line">        shader.<span class="built_in">Unbind</span>();</span><br><span class="line">        vb.<span class="built_in">Unbind</span>();</span><br><span class="line">        ib.<span class="built_in">Unbind</span>();</span><br><span class="line"></span><br><span class="line">        Renderer renderer;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplGlfwGL3_Init</span>(window, <span class="literal">true</span>);</span><br><span class="line">        ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> show_demo_window = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> show_another_window = <span class="literal">false</span>;</span><br><span class="line">        ImVec4 clear_color = <span class="built_in">ImVec4</span>(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">        <span class="type">float</span> r = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="type">float</span> increment = <span class="number">0.05f</span>;</span><br><span class="line">        <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Render here */</span></span><br><span class="line">            renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ImGui_ImplGlfwGL3_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">            shader.<span class="built_in">Bind</span>();</span><br><span class="line">            shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">            renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">                increment = <span class="number">-0.05f</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">                increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">            r += increment;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>);                           <span class="comment">// Display some text (you can use a format string too)</span></span><br><span class="line">                ImGui::<span class="built_in">SliderFloat</span>(<span class="string">&quot;float&quot;</span>, &amp;f, <span class="number">0.0f</span>, <span class="number">1.0f</span>);            <span class="comment">// Edit 1 float using a slider from 0.0f to 1.0f    </span></span><br><span class="line">                ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;clear color&quot;</span>, (<span class="type">float</span>*)&amp;clear_color); <span class="comment">// Edit 3 floats representing a color</span></span><br><span class="line"></span><br><span class="line">                ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Demo Window&quot;</span>, &amp;show_demo_window);      <span class="comment">// Edit bools storing our windows open/close state</span></span><br><span class="line">                ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Another Window&quot;</span>, &amp;show_another_window);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Button&quot;</span>))                            <span class="comment">// Buttons return true when clicked (NB: most widgets return true when edited/activated)</span></span><br><span class="line">                    counter++;</span><br><span class="line">                ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;counter = %d&quot;</span>, counter);</span><br><span class="line"></span><br><span class="line">                ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Render</span>();</span><br><span class="line">            <span class="built_in">ImGui_ImplGlfwGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">            <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Poll for and process events */</span></span><br><span class="line">            <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_Shutdown</span>();</span><br><span class="line">    ImGui::<span class="built_in">DestroyContext</span>();</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后将model matrix以及mvp移入while循环中，这样可以通过滑块更新每次打印时的model matrix.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Render here */</span></span><br><span class="line">    renderer.<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation);		<span class="comment">//每次循环都可以改变model</span></span><br><span class="line">    															<span class="comment">//mat4(1.0f)是indentity matrix</span></span><br><span class="line">    glm::mat4 mvp = proj * view * model;</span><br><span class="line"></span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, r, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1.0f</span>)</span><br><span class="line">        increment = <span class="number">-0.05f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0.0f</span>)</span><br><span class="line">        increment = <span class="number">0.05f</span>;</span><br><span class="line"></span><br><span class="line">    r += increment;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ImGui::<span class="built_in">SliderFloat3</span>(<span class="string">&quot;Translation&quot;</span>, &amp;translation.x, <span class="number">0.0f</span>, <span class="number">960.0f</span>);		<span class="comment">//关联滑块，0到960是之前设置的范围</span></span><br><span class="line">        ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Application average %.3f ms/frame (%.1f FPS)&quot;</span>, <span class="number">1000.0f</span> / ImGui::<span class="built_in">GetIO</span>().Framerate, ImGui::<span class="built_in">GetIO</span>().Framerate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplGlfwGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Poll for and process events */</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="23-Rendering-Multiple-Objects">23 Rendering Multiple Objects</h2>
<p>将</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translationA);</span><br><span class="line">    glm::mat4 mvp = proj * view * model;</span><br><span class="line">    shader.<span class="built_in">Bind</span>();</span><br><span class="line">    shader.<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line"></span><br><span class="line">    renderer.<span class="built_in">Draw</span>(va, ib, shader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个块多次复制即可渲染出多个物体。</p>
<p>然而这样的效率是低下的，因此之后要学习batch rendering.</p>
<hr>
<h2 id="24-Setting-up-a-Test-Framework">24 Setting up a Test Framework</h2>
<p>建立测试，方法是在src/test下建立Test.h，之后建立继承类（本节介绍了TestClearColor）</p>
<p>之后更改Application.cpp以进行测试。但这样很破坏主程序，因此之后将采用菜单的方式测试。</p>
<hr>
<h2 id="25-Creating-Tests">25 Creating Tests</h2>
<p>先在之前的Test.h中添加<code>TestMenu</code>类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line">	~<span class="built_in">TestMenu</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(<span class="type">float</span> deltatime)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Test*&amp; m_CurrentTest;</span><br><span class="line">	std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么不在<code>Test</code>类中用纯虚函数？因为之后的派生类中可以直接不写<code>void OnUpdate(float deltatime) override;</code>以及其他两个；而纯虚函数则不可能这样</p>
</blockquote>
<blockquote>
<p><code>m_Tests</code> 是一个私有成员变量，它是一个 <code>std::vector</code>，这是C++标准库提供的一种动态数组容器。在这个上下文中，<code>std::vector</code> 是一个能够动态增长和缩小的数组，存储类型为 <code>std::pair</code> 的元素。</p>
<p><code>std::pair</code> 是C++标准库提供的一个模板类，它可以存储两个不同类型的值。在这里，<code>std::pair</code> 包含了一个 <code>std::function</code> 对象，该对象可以持有可调用的实体（函数指针、函数对象、Lambda表达式等），以及这个可调用实体返回的 <code>Test*</code> 类型的指针。</p>
<p>所以，<code>m_Tests</code> 是一个动态数组，每个元素是一个 <code>std::pair</code>，其中包含了一个可以返回 <code>Test*</code> 指针的可调用实体。这样的设计通常用于实现一种工厂模式，即根据不同的可调用实体创建不同类型的对象。在这个特定的代码片段中，<code>m_Tests</code> 的目的可能是用于创建不同类型的 <code>Test</code> 对象。</p>
</blockquote>
<p>之后还需要在<code>TestMenu</code>中添加模板函数<code>RegisterTest()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMenu</span> : <span class="keyword">public</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestMenu</span>(Test*&amp; currentTestPointer);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">RegisterTest</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Register test &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">		m_Tests.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(name, []() &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Test*&amp; m_CurrentTest;</span><br><span class="line">	std::vector&lt;std::pair&lt;std::string, std::function&lt;Test*()&gt;&gt;&gt; m_Tests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Lambda 表达式中包含了一个无参数的函数，该函数返回一个新创建的测试类的指针（<code>new T()</code>）。</p>
<p>这是lambda表达式的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line"> // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中的lambda表达式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code</span><br><span class="line">[]() &#123; return new T(); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[]</code> 是一个空的捕获列表，表示lambda表达式没有捕获任何外部变量。</li>
<li><code>()</code> 是参数列表，这里是空的，表示lambda函数不接受任何参数。</li>
<li><code>&#123; return new T(); &#125;</code> 是lambda函数的函数体。它包含一个单一的语句，即使用 <code>new</code> 操作符创建了一个类型为 <code>T</code> 的新对象，并将其指针返回。</li>
</ul>
<p>在这个上下文中，lambda表达式充当了一个无参数函数，每当它被调用时，它会动态地创建一个新的 <code>T</code> 类型的对象，并将对象的指针返回。在这种情况下，lambda表达式被用作一个工厂函数，用于创建不同类型的测试对象。</p>
<p>总结起来，lambda表达式允许你在这个代码中以一种简洁的方式定义了一个匿名的函数，该函数的行为在每次被调用时都是动态的，它用于创建不同类型的测试对象。</p>
</blockquote>
<p>此后修改Application.cpp以完成相应任务</p>
<hr>
<h2 id="26-Creating-a-Texture-Test">26 Creating a Texture Test</h2>
<p>构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">test::TestTexture2D::<span class="built_in">TestTexture2D</span>()</span><br><span class="line">	: <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)), </span><br><span class="line">    <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))), </span><br><span class="line">    <span class="built_in">m_TranslationA</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>), <span class="built_in">m_TranslationB</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> positions[] = &#123;</span><br><span class="line">        <span class="number">-50.0f</span>, <span class="number">-50.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//0</span></span><br><span class="line">         <span class="number">50.0f</span>, <span class="number">-50.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="comment">//1</span></span><br><span class="line">         <span class="number">50.0f</span>,  <span class="number">50.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,  <span class="comment">//2</span></span><br><span class="line">        <span class="number">-50.0f</span>,  <span class="number">50.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>   <span class="comment">//3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">    m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line">    <span class="function">VertexBuffer <span class="title">vb</span><span class="params">(positions, <span class="number">4</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    VertexBufferLayout layout;</span><br><span class="line">    layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">    layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);</span><br><span class="line">    m_VAO-&gt;<span class="built_in">AddBuffer</span>(vb, layout);</span><br><span class="line"></span><br><span class="line">    m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Basic.shader&quot;</span>);</span><br><span class="line">    m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    m_Shader-&gt;<span class="built_in">SetUniform4f</span>(<span class="string">&quot;u_Color&quot;</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    m_Texture = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>);</span><br><span class="line">    m_Shader-&gt;<span class="built_in">SetUniform1i</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时按F5生成整个项目并运行，点击2D Texture会出错。在出错时将线程回到main</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007155213213.png" alt="image-20231007155213213"></p>
<p>根据下面的输出</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007155246373.png" alt="image-20231007155246373"></p>
<p>（此处不知为何跟视频不一样）发现问题发生在<code>TestTexture2D::OnRender()</code>的<code>renderer.Draw(*m_VAO, *m_IndexBuffer, *m_Shader);</code>处</p>
<p>最后发现是上述代码中<code>VertexBuffer vb(positions, 4 * 4 * sizeof(float));</code>有误，因为该<code>vb</code>在上述<code>TestTexture2D</code>的构造函数结束时被析构（也即，调用了<code>~VertexBuffer()</code>）</p>
<hr>
<h2 id="27-How-to-make-your-Uniforms-Faster">27 How to make your Uniforms Faster</h2>
<p>之前做过了，就是在Shader.cpp中添加了一个unordered_map</p>
<p>不过这里进一步将<code>GetUniformLocation()</code>改成const函数，并在unordered_map前添加<code>mutable</code>关键词以示可以修改</p>
<blockquote>
<p>mutable 用来解决常函数中不能修改对象的数据成员的问题。</p>
</blockquote>
<hr>
<h2 id="28-Batch-Rendering-An-Introduction">28 Batch Rendering - An Introduction</h2>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231007171841698.png" alt="image-20231007171841698"></p>
<p>如上图所示，若按原本的方式渲染两个正方形，则需要调用两次draw call. 但若我们将两个vertex buffer以及index buffer合并，则可以在一次draw call完成两个正方形的绘制。与之而来的是，vertex buffer应为动态的，这样在每次绘制前都能传输数据（不是很懂？）</p>
<hr>
<h2 id="29-Batch-Rendering-Colors">29 Batch Rendering - Colors</h2>
<p>只需要在上节基础上加上颜色即可</p>
<hr>
<h2 id="30-Batch-Rendering-Textures">30 Batch Rendering - Textures</h2>
<p>加入另一张图片，用另一个纹理进行采样。构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">test::TestBatchRender::<span class="built_in">TestBatchRender</span>()</span><br><span class="line">     : <span class="built_in">m_Proj</span>(glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">640.0f</span>, <span class="number">0.0f</span>, <span class="number">480.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)),</span><br><span class="line">     <span class="built_in">m_View</span>(glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))),</span><br><span class="line">     <span class="built_in">m_TranslationA</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">0</span>), <span class="built_in">m_TranslationB</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">float</span> positions[] = &#123;</span><br><span class="line">         <span class="number">100.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">200.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">200.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">100.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">         <span class="number">300.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">400.0f</span>, <span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">400.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">300.0f</span>, <span class="number">200.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.93f</span>, <span class="number">0.24f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">         <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">GLCall</span>(<span class="built_in">glEnable</span>(GL_BLEND));</span><br><span class="line">     <span class="built_in">GLCall</span>(<span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));</span><br><span class="line"></span><br><span class="line">     m_VAO = std::<span class="built_in">make_unique</span>&lt;VertexArray&gt;();</span><br><span class="line"></span><br><span class="line">     m_VertexBuffer = std::<span class="built_in">make_unique</span>&lt;VertexBuffer&gt;(positions, <span class="number">8</span> * <span class="number">11</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">     VertexBufferLayout layout;</span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>);  <span class="comment">//postion</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">4</span>);  <span class="comment">//color</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>);  <span class="comment">//texture coordinate</span></span><br><span class="line">     layout.<span class="built_in">Push</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>);  <span class="comment">//texture slot</span></span><br><span class="line">     m_VAO-&gt;<span class="built_in">AddBuffer</span>(*m_VertexBuffer, layout);</span><br><span class="line"></span><br><span class="line">     m_IndexBuffer = std::<span class="built_in">make_unique</span>&lt;IndexBuffer&gt;(indices, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">     m_Shader = std::<span class="built_in">make_unique</span>&lt;Shader&gt;(<span class="string">&quot;res/shaders/Batch.shader&quot;</span>);</span><br><span class="line">     m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">     m_Texture[<span class="number">0</span>] = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/ChernoLogo.png&quot;</span>);</span><br><span class="line">     m_Texture[<span class="number">1</span>] = std::<span class="built_in">make_unique</span>&lt;Texture&gt;(<span class="string">&quot;res/textures/HazelLogo.png&quot;</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         m_Texture[i]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> samplers[<span class="number">2</span>] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">     m_Shader-&gt;<span class="built_in">SetUniform1iv</span>(<span class="string">&quot;u_Textures&quot;</span>, <span class="number">2</span>, samplers);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>OnRender()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> test::TestBatchRender::<span class="built_in">OnRender</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">    Renderer renderer;</span><br><span class="line">    &#123;</span><br><span class="line">        m_Texture[<span class="number">0</span>]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">        glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">        renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        m_Texture[<span class="number">1</span>]-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationB);</span><br><span class="line">        glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">        m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">        renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是留意在构造函数中对两个texture调用<code>Bind()</code>，以及在调用Draw前也要分别Bind</p>
<blockquote>
<p>实话实说，我不知道这么写对不对，虽然结果是对的，但调用了两次Draw，与Batch Rendering理念不符</p>
<p>一种做法或许是设置两个不同的<code>u_MVP</code>？之后做</p>
</blockquote>
<blockquote>
<p>更新：采用另一种函数<code>glBindTextureUnit()</code>完成了想要的效果，但是此时只能由一个滑块来控制（因为两张图片会一起动）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> test::TestBatchRender::<span class="built_in">OnRender</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"><span class="built_in">GLCall</span>(<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT));</span><br><span class="line"></span><br><span class="line">Renderer renderer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTextureUnit</span>(<span class="number">0</span>, m_Texture[<span class="number">0</span>]-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"><span class="built_in">glBindTextureUnit</span>(<span class="number">1</span>, m_Texture[<span class="number">1</span>]-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">glm::mat4 model = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_TranslationA);</span><br><span class="line">glm::mat4 mvp = m_Proj * m_View * model;</span><br><span class="line">m_Shader-&gt;<span class="built_in">SetUniformMat4f</span>(<span class="string">&quot;u_MVP&quot;</span>, mvp);</span><br><span class="line">renderer.<span class="built_in">Draw</span>(*m_VAO, *m_IndexBuffer, *m_Shader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>glBindTexture</code> 和 <code>glBindTextureUnit</code> 是OpenGL中的两个不同的函数，它们用于绑定纹理到纹理单元，但在用法和功能上有一些区别。</p>
<ol>
<li>
<p><strong>glBindTexture</strong>:</p>
<p><code>glBindTexture</code> 函数用于将一个纹理绑定到当前OpenGL上下文的特定纹理目标（例如<code>GL_TEXTURE_2D</code>或<code>GL_TEXTURE_CUBE_MAP</code>）。它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBindTexture</span><span class="params">(GLenum target, GLuint texture)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数将指定的纹理对象（由参数<code>texture</code>指定）绑定到目标<code>target</code>上。绑定后，所有对该目标的纹理操作都会影响到被绑定的纹理对象。这意味着，之后的纹理操作会影响到当前绑定的纹理对象。</p>
</li>
<li>
<p><strong>glBindTextureUnit</strong>:</p>
<p><code>glBindTextureUnit</code> 函数是OpenGL 4.5版本引入的。它允许将一个纹理直接绑定到一个纹理单元（texture unit），而不是特定的纹理目标。这样，一个纹理可以在多个不同的纹理目标之间共享，或者在同一个着色器中绑定到多个不同的纹理目标上。它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glBindTextureUnit</span><span class="params">(GLuint unit, GLuint texture)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数将纹理对象（由参数<code>texture</code>指定）绑定到指定的纹理单元<code>unit</code>上。绑定后，该纹理单元会包含被绑定的纹理对象，而不是特定的纹理目标。这种方法更加灵活，允许在不同的上下文中共享纹理对象，也更适合现代OpenGL编程的需求。</p>
<p>不像之前的OpenGL版本中（如OpenGL 3.x），在OpenGL 4.5及以上版本中，你不再需要在绑定纹理时指定纹理的类型（例如GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP等）。取而代之的是，OpenGL会根据纹理对象的类型自动选择正确的目标。</p>
</li>
</ol>
<p>总的来说，<code>glBindTexture</code> 是OpenGL早期版本中使用的函数，它将纹理对象绑定到特定的纹理目标上，而 <code>glBindTextureUnit</code> 则是OpenGL 4.5引入的新函数，它将纹理对象绑定到纹理单元上，提供了更灵活的纹理绑定方式。</p>
</blockquote>
<blockquote>
<ol>
<li><strong>纹理目标（Texture Target）</strong>：纹理目标是指纹理被绑定到的图形渲染管线的阶段。在OpenGL和DirectX等图形API中，纹理可以绑定到不同的目标上，例如2D纹理、立方体贴图、3D纹理等。不同的纹理目标决定了纹理将如何被使用和渲染。</li>
<li><strong>纹理对象（Texture Object）</strong>：纹理对象是指在图形渲染中用来存储和管理纹理数据的对象。当程序需要使用纹理时，通常会创建一个纹理对象，并将纹理数据加载到该对象中。纹理对象包含了纹理的各种属性和数据。</li>
<li><strong>纹理单元（Texture Unit）</strong>：纹理单元是图形渲染管线中的一个部分，它负责处理纹理采样和纹理操作。在图形渲染中，可以同时使用多个纹理，这些纹理可以在不同的纹理单元上进行绑定。每个纹理单元可以有不同的纹理目标和纹理对象，允许程序在渲染过程中使用多个纹理。</li>
</ol>
<p>纹理目标（Texture Target）、纹理对象（Texture Object）和纹理单元（Texture Unit）之间的关系如下：</p>
<ol>
<li><strong>纹理目标和纹理对象的关系</strong>：
<ul>
<li><strong>纹理目标</strong>指定了纹理被用于渲染管线的哪个阶段，例如2D纹理、立方体贴图等。一个纹理对象可以被绑定到一个特定的纹理目标上。同一个纹理对象可以在不同的渲染阶段被绑定到不同的纹理目标上，以满足渲染需求。</li>
</ul>
</li>
<li><strong>纹理对象和纹理单元的关系</strong>：
<ul>
<li><strong>纹理对象</strong>是存储和管理纹理数据的数据结构。在图形编程中，您通常会创建一个纹理对象，将图像数据加载到这个对象中。一个纹理对象可以被绑定到一个或多个<strong>纹理单元</strong>上。</li>
<li><strong>纹理单元</strong>是图形渲染管线中的一个部分，负责处理纹理采样和纹理操作。每个纹理单元可以有一个纹理对象绑定到上面。当渲染时，着色器程序可以通过纹理单元来访问与之相关联的纹理对象，从而进行纹理采样等操作。</li>
</ul>
</li>
</ol>
<p>综上所述，纹理目标定义了纹理在渲染管线中的用途，纹理对象存储了纹理的数据和属性，而纹理单元则负责管理纹理对象的使用，允许多个纹理对象同时存在，并在渲染过程中被正确地绑定和采样。这三者共同协作，使得在图形渲染中能够有效地使用和处理纹理数据。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/122799884#:~:text=glGenTex,%E5%92%8C%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB">openGL之API学习（一九九）纹理单元和纹理对象的关系-CSDN博客</a></p>
<p>glGenTextures产生的是纹理对象（简称纹理），纹理单元数量在GPU上确定的，不需要创建，glBindTexture将纹理对象绑定到当前纹理单元的的目标类型上（一个纹理单元可以有多个类型1D、2D（注：即纹理目标）等，一个纹理对象能够绑定到多个目标类型上），一个纹理对象可以绑定到多个纹理单元上，一个纹理单元上只能有一个同种纹理类型（如果有多个采样会无所适从）</p>
<p><img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAaGFua2Vybg==,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
</blockquote>
</blockquote>
<p>更新：翻了各种博客，愣是没看出<code>glBindTexture()</code>和<code>glBindTextureUnit()</code>有什么本质上的区别……最后发现是因为没在调<code>Texture::Bind()</code>时加参数……</p>
<p>今天看到收获较大的有关纹理的博客有（可以知道batch rendering-textures的具体代码）：<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/88084372">纹理单元、纹理对象、纹理类型、取样器对象_纹理单元和纹理-CSDN博客</a><br>
[纹理 - LearnOpenGL-CN](<a target="_blank" rel="noopener" href="https://learnopengl-cn.readthedocs.io/zh/latest/01">https://learnopengl-cn.readthedocs.io/zh/latest/01</a> Getting started/06 Textures/)<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/mumufan05/article/details/98970729">OpenGL学习笔记：多个纹理_shader 多个纹理坐标-CSDN博客</a></p>
<p>总结下就是，每个显卡有个最大的纹理单元数，每个纹理单元上可以有多个纹理目标用于绑定纹理对象，纹理对象可以绑定多个纹理目标。<br>
使用纹理必须要：ActivateTexture-&gt;BindTexture-&gt;shader中uniform的关联（一个uniform对应一个纹理单元）<br>
不过现在也是一个滑块控制两个图片，二者同时被移动，不过这也正常，毕竟是一起通过一个draw call绘制的，相对坐标不会变</p>
<hr>
<p>##31 Batch Rendering - Dynamic Geometry</p>
<p>原来的<code>position</code>数组是静态的，现在将之改为可变的</p>
<p>我们首先要修改<code>glBufferData</code>，将之用做分配内存。具体改法是为每个vertex建立struct用于存储各项属性，之后调用<code>glBufferData(GL_ARRAY_BUFFER, 1000 * sizeof(Vertex), nullptr, GL_DYNAMIC_DRAW)</code>. 这里nullptr表明只是用作分配内存，而GL_DYNAMIC_DRAW则表明会动态变化。</p>
<p>此后在<code>BindBuffer()</code>后需要用某种方式将数据发送到vertex buffer. 一种方式是调用<code>glMapBuffer()</code>，这里使用更低版本支持的<code>glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);</code></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.gl/gl4/glMapBuffer">glMapBuffer - OpenGL 4 - docs.gl</a><br>
<a target="_blank" rel="noopener" href="https://docs.gl/gl4/glBufferSubData">glBufferSubData - OpenGL 4 - docs.gl</a></p>
</blockquote>
<p>之后新建函数<code>CreateQuad()</code>，接受三个参数x, y以及textureID，传回两个图片各自所需的<code>std::array&lt;Vertex, 4&gt;</code>并将其<code>memcpy()</code>到<code>vertices</code>中。最后通过ImGui提供的滑块来控制x, y. 最终实现效果与[30 Batch Rendering - Textures](#30 Batch Rendering - Textures)效果类似，只是方式不同，上面是通过调整MVP矩阵实现移动，这里则是改变顶点坐标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> Position[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> Color[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> TextCoord[<span class="number">2</span>];</span><br><span class="line">    <span class="type">float</span> TextID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::array&lt;Vertex, 4&gt; <span class="title">CreateQuad</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">int</span> TextID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> size = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x + size, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; v0, v1, v2, v3 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样写会疯狂报错，因为数组不能像上面那样赋值，因此添加几个struct用于赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::array&lt;Vertex, 4&gt; <span class="title">CreateQuad</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> TextID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> size = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line">    Vertex v0;</span><br><span class="line">    v0.Position = &#123; x, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v0.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v0.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v1;</span><br><span class="line">    v1.Position = &#123; x + size, y, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v1.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v1.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    v1.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v2;</span><br><span class="line">    v2.Position = &#123; x + size, y + size, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.TextCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v2.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    Vertex v3;</span><br><span class="line">    v3.Position = &#123; x, y + size, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.Color = &#123; <span class="number">0.18f</span>, <span class="number">0.6f</span>, <span class="number">0.96f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.TextCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    v3.TextID = TextID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; v0, v1, v2, v3 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个看似没问题，实际上<code>v0.TextCoord</code>出问题了，导致结果如下：</p>
<img src="/2023/10/13/OpenGL%E7%AC%94%E8%AE%B0/image-20231008235827097.png" alt="image-20231008235827097" style="zoom:67%;">
<p>以我目前的水平不足以分析为什么会长成上面这样，不过改对了就行了。（？）</p>
<hr>
<p>完结撒花！前后用时挺久的，大概八月下旬开始做，断断续续到10/8，花了一个半月，不过收获还不错。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenGL/">OpenGL</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="/img/road-8395119_1280.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/13/Git%E7%AC%94%E8%AE%B0/" title="Git笔记"><img class="cover" src="/img/aurora-1185464_1280.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/03/%E9%80%9A%E8%BF%87Selenium%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/" title="通过Selenium实现阿里云盘自动签到"><img class="cover" src="/img/mountains-8379756_1280.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">通过Selenium实现阿里云盘自动签到</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">OpenGL教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#04-Vertex-Buffers-and-Drawing-a-Triangle"><span class="toc-number">1.1.</span> <span class="toc-text">04 Vertex Buffers and Drawing a Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Vertex-Attributes-and-Layouts"><span class="toc-number">1.2.</span> <span class="toc-text">05 Vertex Attributes and Layouts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-How-Shaders-Work"><span class="toc-number">1.3.</span> <span class="toc-text">06 How Shaders Work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-Writing-a-Shader"><span class="toc-number">1.4.</span> <span class="toc-text">07 Writing a Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-How-Do-I-Deal-with-Shaders"><span class="toc-number">1.5.</span> <span class="toc-text">08 How Do I Deal with Shaders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-Index-Buffers"><span class="toc-number">1.6.</span> <span class="toc-text">09 Index Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Dealing-with-Errors"><span class="toc-number">1.7.</span> <span class="toc-text">10 Dealing with Errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Uniforms"><span class="toc-number">1.8.</span> <span class="toc-text">11 Uniforms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Vertex-Arrays"><span class="toc-number">1.9.</span> <span class="toc-text">12 Vertex Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Abstracting-into-Classes"><span class="toc-number">1.10.</span> <span class="toc-text">13  Abstracting into Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Buffer-Layout-Abstraction"><span class="toc-number">1.11.</span> <span class="toc-text">14 Buffer Layout Abstraction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Shader-Abstraction"><span class="toc-number">1.12.</span> <span class="toc-text">15 Shader Abstraction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Writing-a-Basic-Renderering"><span class="toc-number">1.13.</span> <span class="toc-text">16 Writing a Basic Renderering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Textures"><span class="toc-number">1.14.</span> <span class="toc-text">17 Textures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Blending"><span class="toc-number">1.15.</span> <span class="toc-text">18 Blending</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Maths"><span class="toc-number">1.16.</span> <span class="toc-text">19 Maths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Projection-Matrices"><span class="toc-number">1.17.</span> <span class="toc-text">20 Projection Matrices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Model-View-Projection"><span class="toc-number">1.18.</span> <span class="toc-text">21  Model View Projection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-ImGui"><span class="toc-number">1.19.</span> <span class="toc-text">22 ImGui</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Rendering-Multiple-Objects"><span class="toc-number">1.20.</span> <span class="toc-text">23 Rendering Multiple Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Setting-up-a-Test-Framework"><span class="toc-number">1.21.</span> <span class="toc-text">24 Setting up a Test Framework</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Creating-Tests"><span class="toc-number">1.22.</span> <span class="toc-text">25 Creating Tests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Creating-a-Texture-Test"><span class="toc-number">1.23.</span> <span class="toc-text">26 Creating a Texture Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-How-to-make-your-Uniforms-Faster"><span class="toc-number">1.24.</span> <span class="toc-text">27 How to make your Uniforms Faster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Batch-Rendering-An-Introduction"><span class="toc-number">1.25.</span> <span class="toc-text">28 Batch Rendering - An Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Batch-Rendering-Colors"><span class="toc-number">1.26.</span> <span class="toc-text">29 Batch Rendering - Colors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Batch-Rendering-Textures"><span class="toc-number">1.27.</span> <span class="toc-text">30 Batch Rendering - Textures</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Harry</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>